<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Chapter 7: Hardware - Deep Learning Systems: Algorithms, Compilers, and Processors for Large-Scale Production</title>
    <link href="../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../js/jquery-3.2.1.min.js"></script>
    <script src="../js/bootstrap-3.3.7.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Chapter 7: Hardware", url: "#_top", children: [
              {title: "7.1 Moore, Dennard, and Amdahl", url: "#71-moore-dennard-and-amdahl" },
              {title: "7.2 Memory and Bandwidth", url: "#72-memory-and-bandwidth" },
              {title: "7.3 Roofline Modeling", url: "#73-roofline-modeling" },
              {title: "7.4 Processor Designs", url: "#74-processor-designs" },
              {title: "7.5 High-Performance Interconnects", url: "#75-high-performance-interconnects" },
              {title: "7.6 Processors in Production", url: "#76-processors-in-production" },
              {title: "7.7 Platforms Strengths and Challenges", url: "#77-platforms-strengths-and-challenges" },
              {title: "7.8 Evaluating Devices and Platforms", url: "#78-evaluating-devices-and-platforms" },
          ]},
        ];

    </script>
    <script src="../js/base.js"></script>
      <script src="../javascripts/config.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../ch08/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../ch08/" class="btn btn-xs btn-link">
        Chapter 8: Compiler Optimizations
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../ch06/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../ch06/" class="btn btn-xs btn-link">
        Chapter 6: Reducing the Model Size
      </a>
    </div>
    
  </div>

    

    <div id="ch7"></div>
<h1 id="chapter-7-hardware">Chapter 7: Hardware</h1>
<p>The primary components in a DL platform are multitudinous multiplication and addition units, sufficient memory capacity, high memory bandwidth to feed the compute units, high inter-node and inter-server bandwidth for distributed computing, and power to operate. The tradeoffs of architecting DL hardware depend on the targeted workloads and operating environment. The enormous design space includes numerical formats, memory hierarchies, power constraints, area constraints, software- or hardware-managed caches/scratchpads, support for dense and sparse computations, domain-specific to general-purpose compute ratios, compute-to-bandwidth ratios, inter-chip and inter-server interconnects, and ease of programmability.</p>
<p>The cost of arithmetic logic units (ALUs) is decreasing, and computational capacity is growing faster than memory bandwidth, as shown in Figure <a href="../ch07/#fig:comp-bw">7.1</a> for the top supercomputer. The primary hardware bottlenecks executing DL workloads are:</p>
<ul>
<li>
<p>main memory bandwidth;</p>
</li>
<li>
<p>local (SRAM) memory; and</p>
</li>
<li>
<p>power (primarily from data movement).</p>
</li>
</ul>
<div id="fig:comp-bw"></div>
<p><img alt="" src="../figures/ch07-01.png" />
<em>Figure 7.1:</em> Computational capacity is growing faster than memory bandwidth as measured by the capacity of the top supercomputer. Based on [<a href="../biblio/#lindstrom2018">LHL+18</a>].</p>
<p>Moore's Law continues to deliver exponential growth in the number of transistors that can be packed into a given area, albeit at a slower rate than before. Computer architects are finding new ways to extract performance from this exponential growth. However, as a consequence of this exponential growth, compute and memory capacity are increasing much faster than memory bandwidth, which is the bottleneck in many DL workloads. The slow growth in bandwidth relative to compute is known as the <a href="https://dl.acm.org/doi/pdf/10.1145/216585.216588">memory wall</a> or <a href="https://dl.acm.org/doi/10.1145/1555815.1555801">bandwidth wall</a>, where compute units are idled waiting for data [<a href="../biblio/#wulf1995">WM95</a>; <a href="../biblio/#rogers2009">RKB+09</a>].</p>
<p>As transistors shrink, their power density no longer stays constant but rather increases, which is known as the end of <a href="https://ieeexplore.ieee.org/document/1050511">Dennard's scaling</a> (discussed in Section <a href="../ch07/#ch07.sec1">7.1</a>) [<a href="../biblio/#dennard1974">DGY+74</a>]. The amount of <a href="https://en.wikipedia.org/wiki/Dark_silicon">dark silicon</a>, where transistors cannot operate at the nominal voltage, is increasing. This dark silicon motivates the exploitation of transistors for multicore processors and domain-specific circuitry. Some of the existing techniques to increase performance are (detailed in Section <a href="../ch07/#ch07.sec4">7.4</a>):</p>
<ul>
<li>
<p>using a memory hierarchy to facilitate data-reuse;</p>
</li>
<li>
<p>increasing the memory bandwidth;</p>
</li>
<li>
<p>placing the memory close to the compute units to reduce access time and energy;</p>
</li>
<li>
<p>applying a single instruction to multiple data;</p>
</li>
<li>
<p>reducing the numerical representation and compressing the data; and</p>
</li>
<li>
<p>using specialized logic or dedicated accelerators.</p>
</li>
</ul>
<p>Each innovation is a one-time card; that is, each innovation gives a performance boost once since these innovations do not resolve Dennard's scaling. From a clock-speed perspective, devices are not getting any faster.</p>
<p>In order of decreasing access time and increasing die area, the storage types are: nonvolatile memory (flash memory, magnetic disk), DRAM (HBM2/E, GDDR6, DDR4, LPDDR4/5), SRAM (scratchpad, cache), and registers, all discussed in Section <a href="../ch07/#ch07.sec2">7.2</a>. DRAM is often called main memory and SRAM local memory.</p>
<p>Table <a href="../ch07/#tab:energy-area">7.1</a> compares the energy for various operators, including data fetching, in a <a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">von Neumann architecture</a>. DRAM access can cost two orders of magnitude more power and processing cycles over local SRAM. It is crucial to minimize DRAM accesses to improve performance and reduce power consumption.</p>
<div id="tab:energy-area"></div>
<p><em>Table 7.1:</em> Required energy and silicon area for various operator units in a 45 nm technology node. Adopted from <a href="../biblio/#horowitz2014">Hor14</a> and <a href="../biblio/#dally2017">Dal17</a>.
<img alt="" src="../figures/ta07-01.png" /></p>
<p>A smaller numerical representation compute unit requires less area and energy; thus, more units can be added to a given die. The amount of area needed for floating-point multipliers grows quadratically with the number of mantissa bits and linearly with the number of exponent bits.</p>
<p>In Section <a href="../ch01/#ch01.sec8">1.8</a>, we introduced (1) the high-level requirements for the different DL usages: hardware design, topology design, training in production, serving in data centers, and serving in edge devices; and (2) the important hardware features and MAC combinations for training and serving production hardware. Training requires storing and retrieving the activations across all the layers, which typically involves reading and writing several GB of data (the activations) from and to DRAM. In training CNNs, the size of the activations typically has a more significant impact on the total memory requirements than the size of the model. To illustrate, U-Net (used for medical 3D image classification) has <span class="arithmatex">\(20\)</span> million weights but requires <span class="arithmatex">\(256\)</span> GB of memory. Conversely, Megatron-LM-1.2B has <span class="arithmatex">\(1.2\)</span> billion weights but requires <span class="arithmatex">\(32\)</span> GB of memory. Given the amount of data transfer, using a high bandwidth DRAM, such as HBM2E, for training tasks is beneficial. An advantageous design choice is to put enough SRAM to store the model and the activations associated with two consecutive layers in training and inference. Note that the size of the activations is proportional to the batch size, which is usually small for inference.</p>
<p>As much as possible, data center managers want a homogeneous and manageable data center leveraging specialized accelerators only when absolutely needed. However, given the <a href="https://openai.com/blog/ai-and-compute/">exponential</a> demand for compute and the end of Dennard's scaling, the demand for dedicated DL processors is increasing. Hardware designers should be aware of what hyperscalers value:</p>
<ol>
<li>
<p>performance per power and per cost;</p>
</li>
<li>
<p>minimal transition work from an existing to a new hardware/software system;</p>
</li>
<li>
<p>programmability and ease-of-use; and</p>
</li>
<li>
<p>high utilization (the device does not sit idle frequently).</p>
</li>
</ol>
<p>Flexibility is a crucial consideration when designing DL hardware, in particular, because the design is mostly locked around two to three years before the product is deployed, which is a challenge in this rapidly evolving field. Recent algorithmic advancements include depthwise separable convolution, dilated convolutions, residual connections, ReLU variants, and GNNs. New models have irregular memory access patterns, more complex control-flow, and dynamic computation graphs that vary with different input data and cannot be optimized at compile time. These models can benefit from higher general-purpose compute. Models with predictable access patterns and primarily dense linear algebra benefit from dedicated matrix multipliers. Note that the required compute and bandwidth can significantly vary for different workloads, as shown in Figure <a href="../ch01/#fig:fb-wklds">1.16</a>.</p>
<p>The following are important hardware features for training and serving hardware for production workloads in data centers. Software is equally important and discussed in Chapters <a href="../ch08/#ch08">8</a> and <a href="../ch09/#ch09">9</a>. The hardware characteristics for training are:</p>
<ul>
<li>
<p>masses of <span class="arithmatex">\(bf16 \rightarrow fp32\)</span>, <span class="arithmatex">\(fp16 \rightarrow fp32\)</span>, and sufficient <span class="arithmatex">\(fp32 \rightarrow fp32\)</span> MACs;</p>
</li>
<li>
<p>high in-die interconnect (IDI) bandwidth for multicore GEMMs and broadcast/reduce collectives;</p>
</li>
<li>
<p>sufficiently large SRAM for the weights and some activations;</p>
</li>
<li>
<p>high DRAM bandwidth to store and read the activations, or alternatively, a much larger SRAM capacity;</p>
</li>
<li>
<p>high intra-server inter-node bandwidth for (1) multinode GEMM, (2) broadcast/reduce collectives in large embedding layers, and (3) distributed training across nodes (on servers without accelerators, a node can be a socket or a group of cores); and</p>
</li>
<li>
<p>high inter-server bandwidth for distributed training.</p>
</li>
</ul>
<p>For serving:</p>
<ul>
<li>
<p>plenty of <span class="arithmatex">\(fp16 \rightarrow fp32\)</span>, <span class="arithmatex">\(bf16 \rightarrow fp32\)</span>, <span class="arithmatex">\(\mathit{int}8 \rightarrow \mathit{int}32\)</span>, <span class="arithmatex">\(fp8 \rightarrow fp32\)</span> and some <span class="arithmatex">\(fp32 \rightarrow fp32\)</span> MACs;</p>
</li>
<li>
<p>high IDI bandwidth for multicore communication for GEMMs and broadcast/reduce collectives;</p>
</li>
<li>
<p>sufficiently large SRAM for the weights and some activations; and</p>
</li>
<li>
<p>video decoder for media analytic workloads (inference on video frames).</p>
</li>
</ul>
<p>Established hardware companies and several startups have developed or are developing specialized processors and platforms with CPUs, GPUs, FPGAs, CGRAs, DSPs, ASICs, and a mixture of them. The number of DL processors is likely to expand over the next few years and later consolidate. Most of the processors are not going to succeed in the market for two reasons. First, multiple highly specialized processors result in limited volume for each processor, which limits the <a href="https://en.wikipedia.org/wiki/Economies_of_scale">economies of scale</a> and may limit access to the most advanced fabrication processes. The market demand is further limited as some hyperscalers requiring a large volume of processors have built or are building their own. Second, DL engineers are unlikely to learn multiple programming paradigms. The companies that succeed are likely those that delivered a cost-effective programmable and balanced platform with some flexibility to adjust for different requirements, such as the general to domain-specific compute ratio.</p>
<p>In the remainder of this chapter, we review the basic concepts of computer architecture and hardware designs, discuss the various types of memories, and explain workload roofline analysis. Lastly, we compare various DL processors and platforms and their strengths and weaknesses.</p>
<div id="ch07.sec1"></div>
<h2 id="71-moore-dennard-and-amdahl">7.1 Moore, Dennard, and Amdahl</h2>
<p>Demand for more compute, memory, and bandwidth is growing at a time when exponential compute growth is slowing down. In this section, we review the reasons for this slowing down and the ways hardware vendors are partially mitigating this.</p>
<p>At the heart of compute and memory is silicon-made transistor gates. Transistor gates form logic gates, such as the AND, OR, and NOT, which in turn form more complex logic. Transistor gates open and close to block (insulate) or let (conduct) electrical current through by charging or discharging the gate capacitance using voltage. The capacitance is related to the length and width of the transistors. On the one hand, the smaller the capacitance, the less voltage the transistor needs, and the faster it can operate. On the other hand, the less voltage, the less tight the gate closes, and the more current it leaks. Also, as transistors get smaller, both the length of the channel (the region between the source and drain under the gate) and the insulation layers are reduced, which increases the electron tunneling between the source and drain. This tunneling results in current leakage and, as discussed below, is the primary reason for the slowdown in computational growth.</p>
<p><strong>Gordon Moore</strong> <a href="https://ieeexplore.ieee.org/document/4804410">predicted</a> in 1975 that for the next several years the number of transistors that fit in the same chip area would double every two years (revising his 1965 <a href="https://ieeexplore.ieee.org/document/4785860">prediction</a> of doubling per year) through improved technology and innovative techniques [<a href="../biblio/#moore1975">Moo75</a>; <a href="../biblio/#moore1965">Moo65</a>]. This observation is known as <em>Moore's Law</em> and as held for several decades. Today, the exponential growth continues, albeit with a longer than two-year cadence. The primary benefits are less expensive processors, more powerful processors with more transistors and logic per area, or both.</p>
<p><strong>Robert Dennard</strong> et al. <a href="https://ieeexplore.ieee.org/document/1050511">demonstrated</a> that as transistors shrink, their power density stays approximately constant [<a href="../biblio/#dennard1974">DGY+74</a>]. This is known as <em>Dennard's scaling</em>. Combined with Moore's Law, every two years and under the same power budget, the number of transistors per area doubled and operated at <span class="arithmatex">\(40\%\)</span> higher frequencies (details below). Dennard's scaling broke down in the mid-2000s due to current leaking.</p>
<p>The total consumed power (in Watts or Joules per second) is the sum of the dynamic (or switching) power and the static (or leakage) power. Dennard scaling only accounts for the dynamic power, which is defined as follows: </p>
<div class="arithmatex">\[P_{D} = Q\cdot E\cdot f = \frac{1}{2}\cdot Q\cdot C\cdot V^2\cdot f,\]</div>
<p>where <span class="arithmatex">\(E=\frac{1}{2}\cdot C\cdot V^2\)</span> is the energy (in Joules) to open or close a transistor gate, <span class="arithmatex">\(Q\)</span> is the number of active transistors (here we assume all transistors are active), <span class="arithmatex">\(C\)</span> is the capacitance, <span class="arithmatex">\(V\)</span> is the voltage, and <span class="arithmatex">\(f\)</span> is the frequency. Scaling <em>down</em> the transistor dimensions by <span class="arithmatex">\(\kappa&gt;1\)</span>, scales down the area by <span class="arithmatex">\(\kappa^2\)</span>, and scales down the capacitance, charge/discharge time (inverse of frequency), and voltage by <span class="arithmatex">\(\kappa\)</span>. The number of active transistors under the same area is <span class="arithmatex">\(\kappa^2\)</span>, and the dynamic power remains constant: </p>
<div class="arithmatex">\[P_{D} = \frac{1}{2}(Q\cdot \kappa^2)(C/\kappa)(V/\kappa)^2(f\cdot \kappa) = \frac{1}{2}\cdot Q\cdot C\cdot V^2\cdot f.\]</div>
<p>To illustrate, if the transistor dimensions scale by <span class="arithmatex">\(\kappa = \sqrt{2}\approx 1.4\)</span> (per Moore's prediction), then under the same dynamic power and area, the number of transistors doubles and the frequency increases by 40%.</p>
<p>The static power is: </p>
<div class="arithmatex">\[P_{S} = V\cdot I_{\mathit{leakage}},\]</div>
<p>where <span class="arithmatex">\(I_{\mathit{leakage}}\)</span> is the current leakage. Dennard's scaling ended in the mid-2000s due to the increases in static power. Today, reducing the voltage in smaller transistors increases current leakage and increases the power density. Instead of having more clock cycles per second (higher frequency), the focus today is on increasing the instructions per cycle (IPC) or operations per cycle; that is, doing more work per cycle.</p>
<p>Decreasing the voltage increases the <em>static</em> power exponentially. Increasing the voltage increases the <em>dynamic</em> power exponentially, as shown in Figure <a href="../ch07/#fig:power">7.2</a>. There is an ideal voltage that minimizes the sum of the static and dynamic power.</p>
<div id="fig:power"></div>
<p><img alt="" src="../figures/ch07-02.png" />
<em>Figure 7.2:</em> Total power requirement (red curve) across various voltages. Low voltage results in high static power due to current leakage. High voltage results in high dynamic power. There is an optimal voltage <span class="arithmatex">\(V^{*}\)</span> where the total power usage is minimized.</p>
<p>The propagation time <span class="arithmatex">\(T_{\mathit{prop}}\)</span> of the current through all the logic gates in its path needs to be less than <span class="arithmatex">\(1\)</span> clock cycle. As the frequency increases past some <span class="arithmatex">\(f_{\min}\)</span>, higher voltage is required to operate the transistor gates more rapidly. This increase in voltage is approximately linearly proportional to the increase in frequency, as shown in Figure <a href="../ch07/#fig:voltage">7.3</a>. The voltage to operate at <span class="arithmatex">\(f_{\min}\)</span> is <span class="arithmatex">\(V_{\min}\)</span>. Increasing the frequency past <span class="arithmatex">\(f_{\min}\)</span> increases the power to the cube of the frequency increase: <span class="arithmatex">\(\Delta P\propto (\Delta V)^2 \Delta f \propto (\Delta f)^3\)</span>.</p>
<div id="fig:voltage"></div>
<p><img alt="" src="../figures/ch07-03.png" />
<em>Figure 7.3:</em> Increasing the frequency past <span class="arithmatex">\(f_{\min}\)</span> linearly increases the required voltage, and (not shown) cubically increases the dynamic power.</p>
<p>Power generates heat, and too much heat can damage the circuits. There is a maximum power that a system can operate without damaging the circuitry, and this limits the maximum frequency. In fact, over the past decade, the maximum frequency of high-end server processors has not changed much. Servers continue to operate in the <span class="arithmatex">\(2\)</span>-<span class="arithmatex">\(4\)</span> GHz range. Another reason to cap the maximum frequency is related to the maximum distance the electrical current travels in the circuitry. The time it takes to travel this distance must be less than one clock tick, which can be an issue for large circuits when operating at high frequencies.</p>
<p>The primary contributors to the increased dark silicon are the exponential growth in transistors per area, current leakage, and power constraints. Multicore processors and specialized computing are two methods to mitigate dark silicon. These methods have enable the continued growth in computational capacity at the expense of two new challenges: Amdahl's law and the memory wall.</p>
<p><strong>Gene Amdahl</strong> formalized the speedup when only a fraction of a program is improved, known as <a href="https://dl.acm.org/doi/10.1145/1465482.1465560">Amdahl's law</a>. It is used to determine the limitations of parallel computing [<a href="../biblio/#amdahl1967">Amd67</a>]. Using <span class="arithmatex">\(N&gt;1\)</span> cores for a particular workload results in a maximum speed up of </p>
<div class="arithmatex">\[\frac{1}{(1-P)+(P/N)},\]</div>
<p>where <span class="arithmatex">\(P\)</span> is the percentage of the workload that is parallelizable. Approaching this maximum speed up requires nontrivial <em>parallel programming</em>, and there is a computer science field dedicated to this. Even assuming <span class="arithmatex">\(P=1\)</span>, perfect linear scaling across general-purpose multicores is not possible. There are core-to-core bandwidth limitations and cache coherence overhead, which grows with more cores.</p>
<p>These limitations and overheads are motivations to reduce the scope of hardware-based cache coherence and to use domain-specific DL processors for embarrassingly parallel (minimal communication/synchronization between parallel elements) workloads with predictable operations. Solutions still require a way to operate on the right data, and this drives a combination of application-specific hardware and <a href="https://ieeexplore.ieee.org/document/6616543">software-based</a> "coherence" [<a href="../biblio/#alvarez2015">AVG+15</a>; <a href="../biblio/#tavarageri2016">TKT+16</a>; <a href="../biblio/#ashby2011">ADC11</a>].</p>
<p>Figure <a href="../ch07/#fig:processor-trends">7.4</a> provides a high-level view of the trends in microprocessors. The number of transistors per area continues to grow exponentially, and the number of logical cores is following that same growth path; new transistors are primarily used for additional cores. In the future, the growth in the number of cores may slow down, and more transistors utilized for domain-specific acceleration. While frequency has already plateaued, single-thread performance continues to increase due to better instruction pipeline, improved branch prediction, out-of-order execution, larger instruction vectors, and specialized execution units, resulting in more IPC.</p>
<div id="fig:processor-trends"></div>
<p><img alt="" src="../figures/ch07-04.png" />
<em>Figure 7.4:</em> Trends in microprocessors. Source: [<a href="../biblio/#rupp2020">Rup20</a>] (CC BY-SA 4.0 license).</p>
<div id="ch07.sec2"></div>
<h2 id="72-memory-and-bandwidth">7.2 Memory and Bandwidth</h2>
<p>The growth in memory bandwidth has been significantly slower than the growth in computational capacity. The time to read data from memory is often the main hindrance to performance. Moreover, given current trends, this divide between the compute (OPS) and the data transfer (bytes per second) is increasing, which can result in unutilized compute capacity. As an example, the <a href="https://www.nvidia.com/en-us/data-center/tesla-t4/">Nvidia T4</a> card supports up to <span class="arithmatex">\(130\)</span> <span class="arithmatex">\(\mathit{int8}\)</span> TeraOPS (TOPS) with <span class="arithmatex">\(320\)</span> GB/s bandwidth [<a href="../biblio/#nvidia-t42020">Nvi20b</a>]. To keep full utilization, the T4 processor must perform an average of <span class="arithmatex">\(406\)</span> operations on every read byte. One way to reduce exposure to the memory bandwidth is to use a cache memory hierarchy that stores frequently or immediately accessed elements closer to the compute element. The efficiency of caches is dependent on the working set having spatial or temporal locality that can exploit these hierarchies. There is a rich literature on arranging matrices, known as <em>blocking</em> and <em>caching</em>, to fit various memory caches and achieve high data reuse [<a href="../biblio/#goto2008">Gvd08</a>; <a href="../biblio/#chetlur2014">CWV+14</a>; <a href="../biblio/#georganas2018">GAB+18</a>; <a href="../biblio/#zhang2018-b">ZRW+18</a>].</p>
<p>Memory can be described by its capacity (bytes) and data transfer rate or bandwidth (bytes per second). The bandwidth (BW) <a href="https://en.wikipedia.org/wiki/Memory_bandwidth#Bandwidth_computation_and_nomenclature">can be computed</a> as follows: </p>
<div class="arithmatex">\[\text{BW } = f_{\mathit{mem}} \times \mbox{number of interfaces} \times \mbox{transfers per clock} \times \mbox{mem bus width},\]</div>
<p>where <span class="arithmatex">\(f_{\mathit{mem}}\)</span> is the memory frequency, the interfaces are typically <span class="arithmatex">\(2\)</span> (dual-channel configuration) in modern processors, and the transfers per clock are <span class="arithmatex">\(2\)</span> for memories that transfer on both the rising and falling clock edge (such as DDR) and <span class="arithmatex">\(1\)</span> otherwise. In practice, the effective transfers per clock may be slightly lower and workload-dependent; in DRAM, it depends on the distribution of read and write transactions.</p>
<p>The memory types used in production in increasing order of accessed time and, equivalently, in increasing order of memory density (bytes per silicon area) and decreasing monetary cost per byte are as follows:</p>
<ol>
<li>
<p>processor registers;</p>
</li>
<li>
<p>SRAM: scratchpad, cache (typically with multiple levels); and</p>
</li>
<li>
<p>DRAM: HBM2/E, GDDR6, DDR4/5, LPDDR4/5.</p>
</li>
</ol>
<p>There are two types of random-access memory: dynamic RAM (DRAM) and static RAM (SRAM). SRAM uses a bistable circuit design that is faster but more expensive and requires four to six transistors per bit. DRAM is slower but less expensive and requires only one transistor (and a capacitor) per bit, and hence it has higher memory density. The capacitor stores the charge (the bit). Reading the stored bit consumes this charge requiring a write after the read cycle to save the value. Even in the absence of read/write activity, DRAM memory must be frequently refreshed to avoid losing information as the charge leaks (at a temperature and device-dependent rate). This refresh involves reading the data and immediately writing it to the same area (as DRAM reads are destructive). SRAM does not require frequent reads and writes. Both DRAM and SRAM are volatile memories; that is, they lose the stored bits when the power is off.</p>
<p>There are <a href="https://dl.acm.org/doi/10.1145/1273440.1250707">two main types of SRAM</a> configurations: caches and scratchpads [<a href="../biblio/#leverich2007">LAS+07</a>]. A cache is implicitly addressed (not directly addressed by the software), hardware-managed memory. A scratchpad (also called streaming memory) is explicitly addressed, software-managed memory. Caches are common in CPUs and GPUs to support general-purpose workloads. Scratchpads are common in embedded and dedicated hardware, such as ASICs and DSPs, for static graph-based workloads to reduce power consumption.</p>
<p>A cache has additional logic circuitry to ensure cache coherence and improve locality to determine what data to keep (this data is known as <em>hot</em> entries or working set) and what data to replace. This logic alleviates the software (the programmer or compiler) from directly managing the cache memory access. However, it comes at the expense of higher energy cost per data access and lower memory density. This additional logic is beneficial for irregular access patterns, such as in GNNs, embedding layers, and DL dynamic graph-based models.</p>
<p>There can be different levels of caches. Modern CPUs have three-levels of caches: <span class="arithmatex">\(L1\)</span>, <span class="arithmatex">\(L2\)</span> (mid-level cache (MLC)), and <span class="arithmatex">\(L3\)</span> (last-level cache (LLC)). <span class="arithmatex">\(L1\)</span> is the smallest and closest memory to the compute unit, and therefore has the fastest access time. CPU processors have two different <span class="arithmatex">\(L1\)</span> caches: a data cache unit (DCU or <span class="arithmatex">\(L1d\)</span>) and an instruction cache unit (ICU or <span class="arithmatex">\(L1i\)</span>). Data and instructions share the cache in <span class="arithmatex">\(L2\)</span> and <span class="arithmatex">\(L3\)</span>. Modern GPUs have <span class="arithmatex">\(2\)</span> levels of cache. The canonical chunk (block) of memory loaded from the main memory to the cache hierarchy is called a cache line. Note that loading an entire cache line can waste bandwidth and storage on sparsely strided memory accesses.</p>
<p>Different architectures use different cache replacement policy algorithms, and even different cache levels within an architecture may use different policies. While the specific policy used by a microarchitecture is not always made public, variants of the Least Recently Used (LRU) eviction policy are common, such as Adaptive Replacement Cache (<a href="https://en.wikipedia.org/wiki/Adaptive_replacement_cache">ARC</a>). LRU means the cache tracks and evicts the least recently accessed page when adding a new page. ARC tracks frequently used, recently used, and recently evicted pages.</p>
<p>While caches are hardware-managed, there is some work to enhance cache control with software hints. One example is using the <a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">CLDEMOTE</a> instruction, which hints to the hardware to demote a given cache line to more distant cache from the processor to speed up access to the cache line by other cores (L1 caches are unique to a specific core).</p>
<p>A scratchpad has a simple memory structure that provides better efficiency at the expense of sophisticated software; it manages all the memory accesses and the replacement policy. A scratchpad is typically more efficient than a cache, usually <span class="arithmatex">\(1\)</span>-<span class="arithmatex">\(2\)</span> clock cycles per memory access. A scratchpad has addressable storage and requires explicit software-controlled direct memory access (DMA) transfers to orchestrate all data movement in the proper order. However, any mismatch of memory accesses to the ALU or FPU logic inputs or outputs may lead to orders of magnitude of performance degradation. Thus, scratchpads are typically limited to DL workloads with static graphs, where all data accesses are predictable and determined at compile-time. In high-volume production, saving some power and execution time has multiplicative benefits over the lifetime of the model, which may outweigh the software complexity costs.</p>
<p>A hybrid memory system uses both cache and scratchpad configurations. Nvidia architectures (excluding Pascal) <a href="https://docs.nvidia.com/cuda/turing-tuning-guide/index.html#l1-cache">configure</a> some cache memory as a scratchpad for application-specific locality and communication optimizations. Note that Nvidia refers to scratchpad and cache as shared and automatic memory, respectively. There is research toward a unified configuration to get the best of both, such as <a href="https://ieeexplore.ieee.org/abstract/document/7284106">Stash</a> and <a href="https://dl.acm.org/doi/10.1145/3297858.3304025">Buffets</a> [<a href="../biblio/#komuravelli2015">KSA+15</a>; <a href="../biblio/#pellauer2019">PSC+19</a>].</p>
<p>There are three types of caches with different speeds and conflicts tradeoffs. Cache conflicts occur when a different cache line from memory maps to the same cache entry, thus evicting and replacing the existing cache entry. The placement depends on the memory address.</p>
<ul>
<li>
<p><em>Fully Associative</em> places a cache line from memory in any entry in the cache; this has the slowest-access time but minimizes conflicts.</p>
</li>
<li>
<p><em>Direct Mapped</em> places a cache line from memory in a specific entry in the cache; this has the fastest-access time but maximizes conflicts.</p>
</li>
<li>
<p><span class="arithmatex">\(N\)</span><em>-way Set-Associative</em> places a cache line from memory in any of <span class="arithmatex">\(N\)</span> entries in the cache; this provides a compromise between access time and conflicts.</p>
</li>
</ul>
<p>In practice, most CPU caches in production are <span class="arithmatex">\(N\)</span>-way set-associative caches. Understanding cache associativity can guide the design of the DL topology. To illustrate, an <span class="arithmatex">\(fp32\)</span> GEMM with a leading dimension of <span class="arithmatex">\(1024\)</span> (used in an RNN layer with <span class="arithmatex">\(1024\)</span> units), results in high cache conflicts in CPUs; a better leading dimension is <span class="arithmatex">\(1040\)</span> in modern CPUs, as explained in Section <a href="../ch07/#ch07.sec2.sub1">7.2.1</a>.</p>
<p>DRAM or, more precisely today, Synchronous DRAM, is less expensive in price and silicon area but is significantly more expensive in energy and access time compared to SRAM. There are various <a href="https://arxiv.org/abs/1902.07609">types of DRAM</a> used in production: Double Data Rate (DDR), High-Bandwidth Memory (HBM), Graphics DDR (GDDR), and Low-power DDR (LPDDR), and various generations within each type [<a href="../biblio/#ghose2019">GLH+19</a>]. DDR memories fetch the data on both the leading and falling edge of the clock signal. Other types of DRAM with minimal market adoption are Hybrid Memory Cube (HMC) and Wide I/O (WIO).</p>
<h4 id="ddr">DDR</h4>
<p>DDR4 is the most widely used DRAM. It is available in servers, workstations, laptops, and some inference accelerators, such as Habana Goya. Increasing the number of main memory channels improves bandwidth and partially mitigates the <a href="https://ieeexplore.ieee.org/document/6757323">memory wall</a> [<a href="../biblio/#horowitz2014">Hor14</a>; <a href="../biblio/#pedram2017">PRH+17</a>]. However, the maximum number of balls or pins possible on a package limits the number of channels. <a href="https://www.jedec.org/news/pressreleases/jedec-publishes-new-ddr5-standard-advancing-next-generation-high-performance">DDR5</a> is the latest generation of DDR providing <a href="https://www.micron.com/products/dram/ddr5-sdram">higher</a> bandwidth and density. Intel processors codenamed Sapphire Rapids and (likely) AMD processors codename Genoa should support DDR5.</p>
<h4 id="hbm">HBM</h4>
<p>HBM2 is the defacto DRAM memory for GPUs and accelerators targeting training, HPC, and cryptomining. It is available in the Nvidia {P, V, A}100 GPUs and Habana Gaudi. Google TPU v2 and v3 (and likely v4) use HBM but have not made public the specific HBM generation.</p>
<p>HBM2 has a <span class="arithmatex">\(1024\)</span>-bit wide interface across <span class="arithmatex">\(8\)</span> channels per stack, and (in the latest specification) <span class="arithmatex">\({\sim} 2.4\)</span> GT/s transfer rates (each bus lane transfers <span class="arithmatex">\({\sim} 2.4\)</span> Gbps), for a total of <span class="arithmatex">\(307\)</span> GB/s per DRAM stack or package. It provides higher bandwidth and uses less power relative to other DRAM memories. HBM memory connects to the processor via a purpose-built silicon chip called an <em>interposer</em> and mounts in the package substrate, as illustrated in Figure <a href="../ch07/#fig:hbm">7.5</a>. The shorter wires allow for higher bandwidth at lower power. Given that HBM uses a stack of memory chips, it is referred to as 2.5D memory. An issue with HBM is the high price to manufacture the interposer, in part, because 2.5D is a relatively new memory technology. The cost may decrease as the technology gains broad adoption.</p>
<div id="fig:hbm"></div>
<p><img alt="" src="../figures/ch07-05.png" />
<em>Figure 7.5:</em> HBM memory connected to the processor via an interposer. (a) Top view. (b) Side view. Based on [<a href="../biblio/#samsung2016">Sam16</a>].</p>
<h4 id="gddr">GDDR</h4>
<p>GDDR6 is used in the latest gaming graphics cards and data center inference GPUs, such as the Nvidia T4, and may expand to other inference accelerators. Compared to HBM, GDDR is less expensive and has lower latency, but it also has lower bandwidth and lower memory density.</p>
<h4 id="lpddr">LPDDR</h4>
<p>LP-DDR4 and LP-DDR4X are widely used in low power devices, such as mobile phones. LPDDR has short wires and, therefore, low latency response. The newest generation LP-DDR5 is <a href="https://www.jedec.org/category/technology-focus-area/mobile-memory-lpddr-wide-io-memory-mcp">available</a> in the latest mobile phones and expanding to other devices, such as tablets, ultra-thin notebooks, automotive, and tentatively, DL inference processors.</p>
<div id="ch07.sec2.sub1"></div>
<h3 id="721-set-associative-cache">7.2.1 Set-Associative Cache</h3>
<p>Understanding set-associative caches can guide the design of a DL topology. In an <span class="arithmatex">\(N\)</span>-way set-associative cache, the cache is organized into multiple sets with <span class="arithmatex">\(N\)</span> cache lines per set. Each location in the main memory maps to any of the <span class="arithmatex">\(N\)</span> different cache lines of a given set. The index bits from the main memory address determines the set. Accessing a cache line in an already full set evicts one of the <span class="arithmatex">\(N\)</span> entries already present. Note that direct-mapped cache can also be called a <span class="arithmatex">\(1\)</span>-way set-associative cache.</p>
<p>In an <span class="arithmatex">\(N\)</span>-way associative cache, the number of sets is <span class="arithmatex">\(S_N = \mathit{sizeof}(\text{cache})/(N \times \mathit{sizeof}(\text{cache line}))\)</span> with <span class="arithmatex">\(W_N=\mathit{sizeof}(\text{cache})/N\)</span> as the interval of the main memory addresses that map to the same set. That is, equal addresses modulo <span class="arithmatex">\(W_N\)</span> share the same cache set.</p>
<p>Figure <a href="../ch07/#fig:l1">7.6</a> illustrates the cache lines in an <span class="arithmatex">\(8\)</span>-way set-associative <span class="arithmatex">\(L1\)</span> cache with <span class="arithmatex">\(S_N=64\)</span> sets, common in modern CPUs. Each cache line is <span class="arithmatex">\(64\)</span> bytes, the total cache size is <span class="arithmatex">\(64\times 64\times 8=32 \mathit{KiB}\)</span> (<span class="arithmatex">\(Ki=2^{10}\)</span>), and the interval of the main memory addresses that map to the same set is <span class="arithmatex">\(W_N=32Ki/8=4096\)</span> bytes. Note that in this discussion, <span class="arithmatex">\(L1\)</span> cache refers to <span class="arithmatex">\(L1d\)</span> (data) cache.</p>
<div id="fig:l1"></div>
<p><img alt="" src="../figures/ch07-06.png" />
<em>Figure 7.6:</em> A representation of an <span class="arithmatex">\(8\)</span>-way set-associative cache with <span class="arithmatex">\(64\)</span> sets.</p>
<p>The analysis below assumes the matrices used in a program are organized in main memory in column-major order. That is, consecutive values along a matrix's column are consecutive in memory. Furthermore, the number of elements in each column (that is, the number of rows) is called the leading dimension of the matrix.</p>
<p>Data reuse is critical to increasing matrix-multiply (GEMM) performance. A common technique in a GEMM operator is to access the matrices' data in blocks that fit in the cache and to use those values for several computations before accessing another block. However, when a matrix with leading dimensions of <span class="arithmatex">\(1024\)</span> <span class="arithmatex">\(fp32\)</span> values (<span class="arithmatex">\(4096\)</span> bytes) maps to the <span class="arithmatex">\(L1\)</span> cache, all the elements of a given row map to the same cache set, and after accessing <span class="arithmatex">\(8\)</span> elements of a row, the set is full. A cache line is evicted to access another value in the row. Specifically, when the leading dimension is <span class="arithmatex">\(1024\)</span> and a block of <span class="arithmatex">\(16\)</span> rows by <span class="arithmatex">\(k\)</span> columns is accessed (that is, <span class="arithmatex">\(16k\)</span> <span class="arithmatex">\(fp32\)</span> values), the whole block maps to only one set (16 <span class="arithmatex">\(fp32\)</span> values is 64 bytes or one cache line). If <span class="arithmatex">\(k&gt;8\)</span>, the matrix block is evicted from cache every time it is accessed, which results in higher cache misses making caching less effective and reducing the GEMM performance. Using a leading dimension of <span class="arithmatex">\(512\)</span> or <span class="arithmatex">\(256\)</span>, the <span class="arithmatex">\(16\times k\)</span> block maps to <span class="arithmatex">\(2\)</span> or <span class="arithmatex">\(4\)</span> sets (out of <span class="arithmatex">\(64\)</span>), respectively, leading to slightly better but still poor GEMM performance.</p>
<p>For the <span class="arithmatex">\(L1\)</span> cache in this example, the best leading dimensions are <span class="arithmatex">\(1040\)</span> and <span class="arithmatex">\(1008\)</span> because the accessed matrix block spreads across the various cache sets. A recommendation for a data-scientist using <span class="arithmatex">\(fp32\)</span> is to use matrix sizes with a multiple of <span class="arithmatex">\(16\)</span> (a cache line) as the leading dimension, but not a multiple of <span class="arithmatex">\(256\)</span>. This recommendation can influence the design of efficient DL topologies, for instance, designing RNN layers with <span class="arithmatex">\(1008\)</span> units, rather than <span class="arithmatex">\(1024\)</span>.</p>
<p>More generally, for a given matrix, the leading dimension should be a multiple of the number of values that fit in a cache line, but not a multiple of <span class="arithmatex">\(W_N/4\)</span> and, in particular, not a multiple of <span class="arithmatex">\(W_N\)</span>. GEMM software libraries, such as oneMKL, can partially mitigate poor leading dimensions by artificially modifying the matrices' sizes to more efficiently use the cache.</p>
<div id="ch07.sec3"></div>
<h2 id="73-roofline-modeling">7.3 Roofline Modeling</h2>
<p>Roofline <a href="https://dl.acm.org/doi/10.1145/1498765.1498785">modeling</a> estimates the maximum performance that a computational kernel or set of kernels can attain on a particular hardware [<a href="../biblio/#williams2009">WWP09</a>]. A simple roofline model has three components:</p>
<ol>
<li>
<p>processor peak performance in operations (ops) per second (ops/s or OPS);</p>
</li>
<li>
<p>memory bandwidth in bytes per second (B/s); and</p>
</li>
<li>
<p>kernel arithmetic intensity (ops/B).</p>
</li>
</ol>
<p>A processor's peak performance depends on the frequency, number of cores, number of ops per core per cycle, and hardware's efficiency. While some analyses use the theoretical peak, it is better to use the observed or estimated actual peak performance, which includes the processor's efficiency. This efficiency can be estimated based on historical data from highly optimized workloads, or by running a suite of micro-kernels, such as the <a href="https://bitbucket.org/berkeleylab/cs-roofline-toolkit/">CS Roofline Toolkit</a>. This actual peak performance is processor-dependent and kernel independent. Similarly, running a suite of micro-kernels or an appropriate stream benchmark provides a more accurate observable bandwidth, which is a better metric than the theoretical maximum bandwidth.</p>
<p>The arithmetic intensity, also known as operational intensity (OI), is the ratio of the number of operations required to compute a kernel divided by the bytes read from DRAM memory. The literature usually uses <em>AI</em> to abbreviate arithmetic intensity, but we use <em>OI</em> to avoid confusion with <em>artificial intelligence</em>. The number of operations depends on the kernel and is typically independent of the processor. The number of bytes depends on both the kernel and the local SRAM memory size; a large SRAM facilitates data reuse.</p>
<p>A system with no SRAM is assumed to illustrate the worse case OI. If every operand is read from DRAM and every result is written to DRAM, then each operation (two reads and one write) would have an arithmetic intensity of <span class="arithmatex">\(1/(3\times \mathit{sizeof} (\mbox{datatype}))\)</span>. In the ideal case, the operands and result fit in SRAM and the OI is: </p>
<div class="arithmatex">\[\mathit{OI}_{\mathit{kernel}} = \frac{\mathit{ops}}{\mathit{sizeof} (\mbox{input activations}) + \mathit{sizeof} (\mbox{weights})+ \mathit{sizeof}(\mbox{output activations})}.\]</div>
<p>In the literature, OI analyses sometimes assumes this best scenario, making OI independent of hardware. In practice, however, the OI depends on the memory hierarchy.</p>
<p>Figure <a href="../ch07/#fig:roofline">7.7</a> shows a roofline plot. The maximum attainable OPS for a kernel is the <span class="arithmatex">\(\min( \mathit{bandwidth} \times \mathit{OI}, \mathit{peak}\ \mathit{OPS})\)</span>. Kernels where the attainable OPS are constrained by the <span class="arithmatex">\(\mathit{bandwidth} \times \mathit{OI}\)</span> are <em>bandwidth bound</em>, and those constrained by the <span class="arithmatex">\(\mathit{peak}\ \mathit{OPS}\)</span> are <em>compute bound</em>. Increasing the computational capacity does not increase performance for bandwidth bound kernels.</p>
<div id="fig:roofline"></div>
<p><img alt="" src="../figures/ch07-07.png" />
<em>Figure 7.7:</em> A roofline model models the maximum attainable OPS for a particular kernel on a particular hardware. Kernel <span class="arithmatex">\(1\)</span> is well optimized and operating near the roofline. Kernels <span class="arithmatex">\(2\)</span> and <span class="arithmatex">\(3\)</span> are well below the roofline and require better software optimizations to more efficiently use the computational resources.</p>
<p>The relation between roofline and computation time is as follows: the time <span class="arithmatex">\(T\)</span> it takes to execute a kernel, assuming perfect overlap of communication and computation, is: </p>
<div class="arithmatex">\[T= \max \left( \frac{\text{number of ops to compute kernel}} {\text{peak processor OPS}}, \frac{\text{bytes to read from memory}} {\text{peak memory bandwidth}} \right).\]</div>
<p>Data reuse is key to achieving high OI. Data reuse means reusing the operands or the result for multiple cycles. The OI for a kernel function can vary considerably depending on how much data is reused. A traditional CNN kernel has high OI (<span class="arithmatex">\({\sim} 1000\)</span> ops/B), whereas a GEMM kernel used in an MLP, RNN, or other fully-connected layers typically has low OI (<span class="arithmatex">\({\sim} 10\)</span> ops/B) (see Figure <a href="../ch01/#fig:fb-wklds">1.16</a>).</p>
<p>The OI of a <span class="arithmatex">\(\mathbf{C}=\mathbf{A}\times \mathbf{B}\)</span> GEMM operation, assuming the data fits in SRAM, where <span class="arithmatex">\(\mathbf{A}\in\Re^{M\times K}\)</span>, <span class="arithmatex">\(\mathbf{B}\in\Re^{K\times N}\)</span>, and <span class="arithmatex">\(\mathbf{C}\in\Re^{M\times N}\)</span> is: </p>
<div class="arithmatex">\[\mathit{OI} = \frac{2\mathit{MKN}}{\mathit{sizeof}(\mbox{datatype}) \times (2\mathit{MN} + \mathit{MK} + \mathit{KN})},\]</div>
<p>where the <span class="arithmatex">\(2\)</span> in the numerator is to account for multiplies and adds and the <span class="arithmatex">\(2\)</span> in <span class="arithmatex">\(2\mathit{MN}\)</span> in the denominator is to account for reading and writing matrix <span class="arithmatex">\(\mathbf{C}\)</span> from and to main memory. A practical example is a fully-connected layer going from a layer with <span class="arithmatex">\(M\)</span> units to a layer with <span class="arithmatex">\(K\)</span> units and using a batch size of <span class="arithmatex">\(N\)</span> and where matrix <span class="arithmatex">\(\mathbf{A}\)</span> is the weight matrix. Similarly, the OI of an <span class="arithmatex">\(\mathbf{Z}=\mathbf{X} \otimes \mathbf{Y}\)</span> convolution operation assuming the operands fits in SRAM, where <span class="arithmatex">\(\mathbf{X}\in\Re^{NCHW}\)</span>, <span class="arithmatex">\(\mathbf{Y}\in\Re^{KCRS}\)</span>, and <span class="arithmatex">\(\mathbf{Z}\in\Re^{\mathit{NK}\tilde{H}\tilde{W}}\)</span>, is: </p>
<div class="arithmatex">\[\mathit{OI} = \frac{2NKCRS \tilde{H}\tilde{W}} {\mathit{sizeof}(\mbox{datatype}) \times (2N\tilde{H} \tilde{W}K + KCRS + NHWC)}.\]</div>
<p>Element-wise operators have no data reuse and a very low OI. The OI can increase by fusing (merging) element-wise operators with computationally intensive operators, such as GEMM and convolution. For instance, the ReLU operator can be applied to the output of a convolution operation while the output data is still in the registers before writing it back to the cache or main memory.</p>
<p>Even when the operands do not fully fit in SRAM, GEMM and convolution operators can take advantage of data reuse. In the <span class="arithmatex">\(\mathbf{C}=\mathbf{A}\times \mathbf{B}\)</span> GEMM operation above, every value in matrix <span class="arithmatex">\(\mathbf{B}\)</span> is reused <span class="arithmatex">\(M\)</span> times: every value in row <span class="arithmatex">\(k\in[0,K-1]\)</span> in matrix <span class="arithmatex">\(\mathbf{B}\)</span> is multiplied by all the <span class="arithmatex">\(M\)</span> values in the corresponding column <span class="arithmatex">\(k\)</span> in matrix <span class="arithmatex">\(\mathbf{A}\)</span>. Every value in <span class="arithmatex">\(\mathbf{C}\)</span> is reused <span class="arithmatex">\(K\)</span> times as it accumulates the <span class="arithmatex">\(K\)</span> products. Weight reuse (the data in matrix <span class="arithmatex">\(\mathbf{A}\)</span>) is proportional to the batch size <span class="arithmatex">\(N\)</span>; a batch size of <span class="arithmatex">\(N=1\)</span> has no weight reuse in a GEMM operation.</p>
<p>In the convolution operator, there is more data reuse. The weights of one filter <span class="arithmatex">\(\mathbf{Y}_k\in\Re^{\mathit{CRS}}\)</span> can be reused across the <span class="arithmatex">\(N\)</span> dimension in the input tensor <span class="arithmatex">\(\mathbf{X}\)</span>. Alternatively, the activations across one sample, <span class="arithmatex">\(\mathbf{X}^{[n]}\in\Re^{\mathit{HWC}}\)</span>, can be reused across all weights <span class="arithmatex">\(\mathbf{Y}\)</span>.</p>
<div id="ch07.sec4"></div>
<h2 id="74-processor-designs">7.4 Processor Designs</h2>
<p>There are various types of architectures with different instruction sets, memory, and compute designs. In this section, we review instruction sets, and the type of processors used in DL, specifically CPUs, GPUs, FPGAs, CGRAs, DSPs, and ASICs, used separately or as components of a heterogeneous design. Given the prevalence of CPUs, GPUs, and ASICs, most of the focus is on these processors. These types of architectures balance flexibility (general-purpose computing) and performance (specialized computing), as illustrated in Figure <a href="../ch07/#fig:flexibility-power">7.8</a> across generalized architectures. In practice, the actual tradeoff depends on the specific microarchitecture; for example, recent Nvidia microarchitectures have specialized (ASIC-like) compute units for matrix multiplications, which increases peak OPS at the expense of higher software complexity. In this section, we introduce key characteristics of each of these processors, and in Section <a href="../ch07/#ch07.sec6">7.6</a>, we discuss prominent processors in production and development.</p>
<div id="fig:flexibility-power"></div>
<p><img alt="" src="../figures/ch07-08.png" />
<em>Figure 7.8:</em> A generalization of different architectures providing tradeoffs between hardware efficiency and software flexibility (ease of programming). In practice, the actual tradeoff depends on the specific microarchitecture.</p>
<p>The instruction set architecture (ISA) defines the operators, data types, and memory management for an abstract computer architecture. Different processors with different frequencies and memory sizes can implement the same ISA and execute the same binary. The specific implementation is called a <em>microarchitecture</em>. For instance, the x86 ISA implementation is different in Intel, AMD, and Centaur microarchitectures. The processor contains the circuit logic to execute the set of instructions. ASICs have unique ISAs usually not shared publicly.</p>
<p>Two general types of instruction sets are the complex instruction set computer (CISC) and the reduced instruction set computer (RISC). The CISC ISA aims to execute multiple low-level operations per instruction. The RISC ISA is smaller and simpler than the CISC ISA and aims to provide higher IPC rates. The most common instruction sets and the typical devices that use them are as follows:</p>
<ul>
<li>
<p>CISC x86 ISA in computer processors from laptops to supercomputers;</p>
</li>
<li>
<p>RISC Arm ISA in smartphones with some adoption in laptops and single-board computers and starting to enter the server market by <a href="https://amperecomputing.com/">Ampere</a>, <a href="https://aws.amazon.com/ec2/graviton/">AWS-Graviton</a>, <a href="https://www.marvell.com/server-processors/thunderx-arm-processors/thunderx-cp/">Marvell</a>, and <a href="https://www.huawei.com/en/press-events/news/2019/1/huawei-unveils-highest-performance-arm-based-cpu">Huawei</a>;</p>
</li>
<li>
<p>RISC open-sourced RISC-V ISA in academia with some small traction in production at <a href="https://www.t-head.cn/product/c910">Alibaba</a> and <a href="https://www.sifive.com/cores/u74-mc">SiFive</a>; and</p>
</li>
<li>
<p>RISC Power ISA in IBM POWER microprocessors and some supercomputers.</p>
</li>
</ul>
<p>There are different ways to parallelize a kernel in hardware, such as with SIMD/SIMT instructions, multicores, or systolic architectures. Also, model parallelism techniques, discussed in Section <a href="../ch06/#ch06.sec3">6.3</a>, can distribute the kernel's computations among multiple nodes.</p>
<p>Single instruction, multiple data (SIMD), and single instruction, multiple threads (SIMT) (<a href="https://www.nvidia.com/content/PDF/fermi_white_papers/NVIDIA_Fermi_Compute_Architecture_Whitepaper.pdf">coined</a> by Nvidia), are used by CPU and GPU vector processors, respectively. In CPUs, a SIMD instruction is concurrently applied to all the values in the respective registers within an execution unit (EU) in a core. To illustrate, an AVX-512 instruction execution unit (EU) may take two 512-bit input registers, each with <span class="arithmatex">\(16\)</span> <span class="arithmatex">\(fp32\)</span> values, and computes the element-wise product across the registers and stores the resulting <span class="arithmatex">\(16\)</span> <span class="arithmatex">\(fp32\)</span> values in another 512-bit register. GPUs generalize SIMD with SIMT; rather than apply an instruction to data in registers, GPUs apply an instruction across multiple threads (a <em>warp</em> or <span class="arithmatex">\(32\)</span> threads in Nvidia GPUs and a <em>wavefront</em> or <span class="arithmatex">\(64\)</span> threads in AMD GPUs). Specifically, GPUs use <a href="https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#memory-optimizations">coalesced loads</a>, where different values in the same cache line are concurrently accessed and used by the threads in a warp or wavefront.</p>
<p>SSE, MMX, AVX, AVX-2, and AVX-512 (sometimes called AVX-3) are SIMD instruction extensions to the x86 ISA, and NEON and the Scalable Vector Extensions (SVE) are SIMD instruction extensions to the Arm ISA (do not worry if you are unfamiliar with these ISAs). The primary differences between these ISA extensions are the number of supported instructions and the data size that the instruction can be concurrently applied. For example, AVX-512 has more instructions than AVX-2 and concurrently operates on 512 bits, whereas AVX-2 operates on 256 bits.</p>
<p>Nvidia provides a pseudo-assembly language virtual ISA called the <em>Parallel Thread Execution</em> (PTX). Compilers, such as GCC (detailed in Section <a href="../ch08/#ch08.sec2">8.2</a>), <a href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html#instruction-set-ref">generate PTX code</a>. PTX code requires using Nvidia's NVCC compiler to access the physical ISA known as <a href="https://docs.nvidia.com/nsight-visual-studio-edition/4.6/Nsight_Visual_Studio_Edition_User_Guide.htm#PTX_SASS_Assembly_Debugging.htm">SASS</a> to generate an executable binary [<a href="../biblio/#nvidia-sass2015">Nvi15</a>]. Recent AMD GPUs use the <a href="https://developer.amd.com/wp-content/resources/Vega_7nm_Shader_ISA.pdf">Vega</a> ISA, <a href="https://developer.amd.com/wp-content/resources/RDNA_Shader_ISA.pdf">RDNA</a> ISA, or CDNA ISA.</p>
<p><a href="https://en.wikipedia.org/wiki/Simultaneous_multithreading">Simultaneous multithreading</a> (SMT), called <a href="https://en.wikipedia.org/wiki/Hyper-threading">hyper-threading</a> for Intel processors, is used in CPUs to run two (and potentially four or more) threads in one core to utilize better the EUs that may otherwise be idled. For well-optimized kernels, however, an EU may not sit idle, and using two threads may not provide a significant gain in performance. In high OI kernels, enabling SMT could reduce the performance due to the thread switching overhead. Experimentation is required to assess the gains or losses of SMT on a particular workload.</p>
<p>Another set of instructions designed to exploit instruction-level parallelism is the very long instruction word (VLIW) instructions, where multiple instructions execute in parallel. VLIW processors work best with regular, predictable code for the compiler to extract the required level of parallelism. The retired Itanium, and today's Habana AI processors as well as Google's <a href="https://cacm.acm.org/magazines/2020/7/245702-a-domain-specific-supercomputer-for-training-deep-neural-networks/fulltext">TPU v2</a> (and perhaps v3 and v4) use VLIW SIMD vector processors.</p>
<p>Dataflow parallelism uses systolic architectures (also called dataflow architectures or dataflow processors) with multiple simple processing engines (PEs). A PE performs a simple computation, such as a MAC, and passes the result to its neighbor PE. The collected work across all PEs results in high throughput. Given the simple circuitry design, dataflow architectures can be power-efficient. In a systolic array, the PEs connect in a mesh pattern; the shorter wires connect nearby PEs and provide high bandwidth at much lower power than longer wires. Dataflow parallelism is adopted in specialized hardware discussed below, including in domain-specific circuitry added to CPUs and GPUs, such as Intel's <a href="https://software.intel.com/content/dam/develop/public/us/en/documents/architecture-instruction-set-extensions-programming-reference.pdf">AMX</a> and Nvidia's tensor cores. Dataflow processors work best with regular, predictable code. Using systolic architectures (and SIMD and SIMT) near peak performance, requires a mature compiler or program that considers the memory hierarchy. A minor mismatch from memory access to the systolic dataflow processor can lead to orders of magnitude of slower performance.</p>
<p>A <strong>central processing unit (CPU)</strong> consists of RAM, registers, and execution units. RAM holds both the program instructions and the data. A server CPU typically has faster but fewer cores compared to a GPU or a dedicated DL accelerator. It may better balance complex workloads: the parallelizable code can benefit from the many CPU cores, and the serial code can benefit from the single-core high-frequency performance. Note that the execution time does not decrease linearly with increased core count, per Amdahl's law. A CPU provides maximum flexibility and is typically simpler to program than other hardware. It has built-in logic to exploit control-flow, including branch prediction. This flexibility comes at the expense of higher power consumption to decode and execute the instructions in each core. Embarrassingly parallel workloads with static graphs do not require many of the capabilities of the CPU, and a dedicated processor should provide higher performance per watt.</p>
<p>A <strong>graphical processing unit (GPU)</strong> consists of RAM, registers, and compute units. GPUs are designed for embarrassingly parallel tasks, initially targeting image manipulation by simultaneously applying an operator to each pixel or group of pixels, and later targeting DL matrix multiplications and convolutions. A difference between a CPU and a GPU core is that the CPU core can decode and execute an instruction independently of the other core. A GPU core executes the same instruction as the other cores in their group, known as a warp and wavefront by Nvidia and AMD, respectively. The CPU cores provide more flexibility than GPU cores, and the GPU cores provide higher energy efficiency than CPU cores.</p>
<p>A CPU core is an independent processor with dedicated ALUs, control logic, local SRAM with a dedicated <span class="arithmatex">\(L1\)</span> cache, and multiple registers shared only between the SMT threads (when SMT is enabled). A GPU core cannot operate independently of other cores; it has dedicated registers but not dedicated SRAM; instead, it shares the memory with all the cores in the warp or wavefront. Given the limitations of a GPU core, some literature refers to them as threads. The warp or wavefront can be thought of as a core with massive SMT capabilities. Compared to CPUs, GPUs use much larger register files similar in sizes to a CPU's LLC to support the massive SMTs at higher throughput at the expense of higher latency.</p>
<p>A typical bottleneck is the limited memory bandwidth. Increasing the SRAM associated with every compute unit or PE can mitigate this. Design choices range from Nvidia's V100 with large HBM2 and small local SRAM to Graphcore's Colossus with no DRAM and large SRAM units that take most of the silicon area, as illustrated in Figure <a href="../ch07/#fig:mem-designs">7.9</a>, and to emerging in-memory processing technology. The design choices affects the batch size required to achieve high efficiency. Hardware with more local SRAM can have higher compute utilization with small batch sizes, which can benefit both training and inference. Training with small batch sizes requires less hyperparameter tuning to converge. Inference with small batch sizes (often a batch size of one) is typical to meet latency constraints.</p>
<div id="fig:mem-designs"></div>
<p><img alt="" src="../figures/ch07-09.png" />
<em>Figure 7.9:</em> The memory designs under the same power consumption range from using (left) HBM and small local SRAM to using (right) multiple SRAM units that take most of the silicon area and no DRAM. Blue rectangles represent the memory and yellow rectangles the compute units.</p>
<p>A <strong>field-programmable gate array (FPGA)</strong> is a type of hardware with some small compute elements (logic blocks), such as memory, registers, lookup tables, and macro functions, and whose connectivity is reconfigurable and can be programmed. This programmability is beneficial to adapt to new workloads that require different hardware characteristics. Also, FPGAs are used to simulate ASICs and other processor designs before building them. Two challenges with FPGAs are the long compilation time (several minutes to hours) to reprogram the logic gates and the limited DL software tools.</p>
<p>A <strong>coarse-grained reconfigurable array (<a href="https://dl.acm.org/doi/10.1145/3357375">CGRA</a>)</strong> is also a type of programmable hardware [<a href="../biblio/#liu2019-e">LZL+19</a>]. A CGRA can be thought of as an FPGA with coarser reconfigurability. Thus, in theory, a CGRA provides easier programmability but less flexibility compared to an FPGA. In practice, CGRAs have limited adoption due to the limited software tools.</p>
<p>A <strong>digital signal processor (DSP)</strong> is a specialized, low-latency microprocessor with a specialized ISA optimized for frequently used functions in signal processing, like convolution. Modern DSPs are modular in that they may have a base ISA that is consistent, and an extension ISA that is specific to the type of processing (for instance, for image, audio, and network signals). Unlike a CGRA, a DSP is not reconfigurable. DSPs are programmable but require a good compiler for high performance. DSPs are typically used in combination with other hardware in a heterogeneous design.</p>
<p>An <strong>application-specific integrated circuit (ASIC)</strong> provides the best performance for a specific application but is the least flexible. ASICs have limited control logic and depend on the programmer or compiler to manage data movement. Achieving high-utilization requires experienced low-level programmers or a matured DL compiler. Current DL compilers are still immature and require significant time to map the kernels to execute efficiently in hardware. Given the software complexity, ASICs work best with regular, predictable code. Some newer models have dynamic graphs with complex datapaths that are difficult to compile efficiently. ASICs are often used as part of a DL design with other architectures to handle the computationally intensive operators.</p>
<p>Most ASICs use dataflow architectures for MAC computations. A recommended high-level design for an ASIC is to pack as many transistors as possible into a die for MACs operators (the die size and power constrained by the deployment environment) to support matrix-wise operators. Then, use some of the silicon for element-wise operators, matrix transposes, and I/O, and use most of the rest for SRAM. The processor should operate at or slightly above the <span class="arithmatex">\(V_{\min}\)</span> voltage to ensure the highest ops/s per watt. Increasing the frequency past <span class="arithmatex">\(f_{\min}\)</span> increases the power with the cube of the increased frequency (see Section <a href="../ch07/#ch07.sec1">7.1</a>).</p>
<p>There are various ways to implement MACs with dataflow parallelism. Chen et al. and Sze et al. <a href="https://ieeexplore.ieee.org/abstract/document/7948671">provide</a> a detailed <a href="https://www.morganclaypool.com/doi/abs/10.2200/S01004ED1V01Y202004CAC050">review</a> of various dataflow architectures [<a href="../biblio/#chen2017-b">CES17</a>; <a href="../biblio/#sze2020">SCY+20</a>]. These architectures have an array of PEs connected via a network-on-chip (NoC) with global SRAM memory, as illustrated in Figure <a href="../ch07/#fig:pe-array">7.10</a> for a <span class="arithmatex">\(3\times 3\)</span> array (in practice, the arrays are larger). The PE array gets the activations (Act), weights, and accumulated sum from the global SRAM. Each PE contains the ALU or FPU logic to perform MAC operations, a local control unit, and may have a local SRAM scratchpad (Spad). The MAC unit multiplies a set of weights and activation and adds the result to the accumulated partial sum.</p>
<div id="fig:pe-array"></div>
<p><img alt="" src="../figures/ch07-10.png" />
<em>Figure 7.10:</em> An accelerator chip with a <span class="arithmatex">\(3\times 3\)</span> array of PEs. Each PE has a MAC unit that multiplies a set of weights and activations and adds the result to the accumulated sum. Based on [<a href="../biblio/#sze2017">SCY+17</a>].</p>
<p>There are <a href="https://ieeexplore.ieee.org/abstract/document/7948671">four types</a> of dataflow architectures: no local reuse, weight-stationary, output-stationary, and row-stationary [<a href="../biblio/#chen2017-b">CES17</a>].</p>
<p><strong>No Local Reuse</strong> maximizes the size of the global SRAM by not having local PE memory. The weights and activations pass from the global SRAM to each PE, with passes the accumulated sum to its neighbor along a row of PEs, as illustrated in Figure <a href="../ch07/#fig:nlr">7.11</a>.</p>
<div id="fig:nlr"></div>
<p><img alt="" src="../figures/ch07-11.png" />
<em>Figure 7.11:</em> No local reuse dataflow architecture. Based on [<a href="../biblio/#sze2017">SCY+17</a>].</p>
<p><strong>Weight-Stationary</strong> maximizes weight reuse by storing the weights in the PE's local memory. An activation is broadcasted to the relevant PEs, and the accumulated sum flows from each PE to its neighbor along a row of PEs, as illustrated in Figure <a href="../ch07/#fig:ws">7.12</a>. This data flow works well for traditional convolutional layers that reuse the weights. It is not efficient for fully-connected layers or convolutional layers with limited weight reuse, such as <span class="arithmatex">\(1\times 1\)</span> convolution or depthwise separable convolutions.</p>
<div id="fig:ws"></div>
<p><img alt="" src="../figures/ch07-12.png" />
<em>Figure 7.12:</em> Weight-stationary dataflow architecture. Based on [<a href="../biblio/#sze2017">SCY+17</a>].</p>
<p><strong>Output-Stationary</strong> maximizes reuse of the accumulated sums by storing them in the PE's local memory. A weight is broadcasted to all the relevant PEs. The activations flow from each PE to its neighbor along a row of PEs, as illustrated in Figure <a href="../ch07/#fig:os">7.13</a>.</p>
<div id="fig:os"></div>
<p><img alt="" src="../figures/ch07-13.png" />
<em>Figure 7.13:</em> Output-stationary dataflow architecture. Based on [<a href="../biblio/#sze2017">SCY+17</a>].</p>
<p><strong>Row-Stationary</strong> maximizes reuse across weights and activations. The accumulated sums flow from the bottom to the top columns, as illustrated in Figure <a href="../ch07/#fig:rs">7.14</a>. Row-Stationary, <a href="https://ieeexplore.ieee.org/abstract/document/7948671">proposed</a> by Chen et al., provides the best performance per watt for convolutions and fully-connected layers [<a href="../biblio/#chen2017-b">CES17</a>; <a href="../biblio/#chen2016-c">CES16</a>].</p>
<div id="fig:rs"></div>
<p><img alt="" src="../figures/ch07-14.png" />
<em>Figure 7.14:</em> Row-stationary dataflow architecture. Based on [<a href="../biblio/#sze2017">SCY+17</a>].</p>
<p>An operation may not distribute evenly across all the PEs in the array. <a href="https://dl.acm.org/doi/abs/10.1145/3358198">dMazeRunner</a> efficiently explores the various ways to split computational kernels in a dataflow accelerator [<a href="../biblio/#dave2019">DKA+19</a>].</p>
<p>ASICs can also be customized to better support sparse matrix multiplications. Nvidia researchers demonstrated the benefits of sparse multiplications with the <a href="https://dl.acm.org/doi/10.1145/3352460.3358275">ExTensor accelerator</a> that rapidly finds intersections of nonzero operands and avoids multiplies by zero [<a href="../biblio/#hegde2019">HAP+19</a>].</p>
<p>Compute-in-memory and neuromorphic processors are two different designs; both have challenges and no adoption in production. A <strong><a href="https://iopscience.iop.org/article/10.1088/1361-6463/aac8a5">compute-in-memory</a> processor</strong> uses analog computations [<a href="../biblio/#tsai2018">TAN+18</a>]. The tunable resistors represent the weights, the voltage represents the activations, and the measured output current represents the accumulated sum. While very efficient to multiply values, this type of hardware requires meticulous weight tuning to mitigate statistical performance degradation. Furthermore, the expensive digital-to-analog (DAC) and analog-to-digital converter (ADC) limit overall power savings.</p>
<p>A <strong><a href="https://www.nature.com/articles/s41586-019-1677-2">neuromorphic processor</a></strong> is a type of brain-inspired processor that attempts to reduce power consumption in comparison to other DL hardware [<a href="../biblio/#roy2019">RJP19</a>]. It uses spiking neural networks (SNNs) at very low power. However, its success is limited to simple domains and has lower statistical performance than traditional artificial neural networks (ANNs). The input-to-output function is nondifferentiable, preventing the use of the backpropagation algorithm, except as an <a href="https://arxiv.org/abs/1903.06379">approximation</a> [<a href="../biblio/#lee2019">LLH+19</a>; <a href="../biblio/#zhang2019-c">ZL19</a>].</p>
<div id="ch07.sec5"></div>
<h2 id="75-high-performance-interconnects">7.5 High-Performance Interconnects</h2>
<p>Training and inference benefit from high-performance interconnects for data ingestion, model parallelism, and data parallelism. The types of interconnects discussed in this section are host-to-device, such as PCIe and CXL and device-to-device and host-to-host, such as InfiniBand, OmniPath, and Ethernet/IP. Hyperscalers typically use commodity interconnects, such as Ethernet, to lower operational costs, unlike in HPCs, where it is common to use custom fabrics [<a href="../biblio/#al-fares2008">ALV08</a>].</p>
<p>Host-device interactions focus on efficiently allocating the computations between the host and the device. For instance, the host may be responsible for data cleaning and preprocessing before handling the data off to the device for dense computation. Host-to-host and device-to-device interactions focus on supporting parallel computation involving multiple instances of the host or the device, such as for distributed training. Host-storage interactions focus on feeding the training dataset to the host or hosts.</p>
<p>Serializer/Deserializer (SerDes) is used for data transfers. A SerDes chip converts parallel data to serial data to be transmitted over a much higher speed connection and vice versa. Multiple SerDes interfaces are often used in a single package. SerDes standards include the Peripheral Component Interconnect Express (PCIe) bus and Ethernet. Proprietary SerDes are used in Nvidia's <a href="https://www.nvidia.com/en-us/data-center/nvlink/">NVLink</a>, Nvidia Mellanox <a href="https://www.mellanox.com/products/interconnect/infiniband-overview">InfiniBand</a>, and AMD's <a href="https://en.wikichip.org/wiki/amd/infinity_fabric">Infinity Fabric</a>.</p>
<p>The PCIe bus is an industry bus standard that connects various devices, such as the host CPU, GPUs, accelerators, Ethernet, and other I/O devices commonly found in modern computers, such as SATA and USB. PCIe interfaces can be configured in different number of lanes (or widths) based on the intended application of the computer system design. The theoretical peak bandwidths per direction using <span class="arithmatex">\(16\)</span> lanes (written as <span class="arithmatex">\(\times 16\)</span>) are doubling in almost every generation <a href="https://en.wikipedia.org/wiki/PCI_Express">as follows</a>:</p>
<ul>
<li>
<p>PCIe <span class="arithmatex">\(3.0\ \times 16\)</span>: <span class="arithmatex">\(16\)</span> GB/s (most common)</p>
</li>
<li>
<p>PCIe <span class="arithmatex">\(4.0\ \times 16\)</span>: <span class="arithmatex">\(31.5\)</span> GB/s (recently available)</p>
</li>
<li>
<p>PCIe <span class="arithmatex">\(5.0\ \times 16\)</span>: <span class="arithmatex">\(63\)</span> GB/s (future)</p>
</li>
</ul>
<p>The Compute Express Link (<a href="https://www.computeexpresslink.org/about-cxl">CXL</a>) is a new high-speed CPU-to-device interconnect that can maintain memory coherency between the CPU and device memory. The technology is built on PCIe and leverages the PCIe <span class="arithmatex">\(5.0\)</span> physical and electrical interface, meaning CXL and PCIe are electrically identical. They both use the same PCIe form factor <a href="https://pcisig.com/evolution-cem-connectors-almost-20-years-making">CEM</a>, which allows using a single slot in a server for PCI or CXL devices. However, CXL and PCIe have different and incompatible protocols.</p>
<p>High-performance network protocols which support efficient scaling of accelerators include RDMA over Converged Ethernet (<a href="https://en.wikipedia.org/wiki/RDMA_over_Converged_Ethernet">RoCE</a>), <a href="https://en.wikipedia.org/wiki/InfiniBand">InfiniBand</a>, <a href="https://en.wikipedia.org/wiki/IWARP">iWARP</a>, and <a href="https://en.wikipedia.org/wiki/Omni-Path">Omni-Path</a>. These network protocols allow remote direct memory access (RDMA). RDMA utilizes the memory subsystem and maps a remote memory region to be accessible directly by the network interface controller (<a href="https://en.wikipedia.org/wiki/Network_interface_controller">NIC</a>) to obtain higher bandwidths without being bottlenecked by connection to the host, or via a software construct to shared memory that consumes CPU cycles. It is up to other technologies to allow this mapping and get the RDMA to the correct destination. In the case of RDMA to CPU memory, it is through the memory controller in the CPU. In the case of two devices that support PCIe peer-to-peer (P2P), it is a P2P transaction between the devices. NVLink is a different interface and protocol which enables direct GPU to GPU memory sharing and communication between Nvidia GPUs. AMD GPUs use Infinity Fabric. Other accelerators are adding interfaces, often proprietary and optimized for their specific architecture, to allow for direct device-to-device memory sharing or communication to provide high bandwidth, multidevice scaling.</p>
<p>There is a difference between the protocol for the chip-to-chip interconnect, such as PCIe and Ethernet, and the actual physical interconnect (<a href="https://en.wikipedia.org/wiki/PCI_Express#Physical_layer">PHY</a>), which can carry multiple types of protocols on top of it. The PHY Interface for PCIe (PIPE) is used for PCIe, CXL, and USB 3.0 SuperSpeed. The <a href="https://pcisig.com/">PCI-SIG</a> and the <a href="https://standards.ieee.org/standard/802_3-2018.html">IEEE 802.3</a> define and manage the PCIe and Ethernet standards, respectively. The Optical Internetworking Forum (<a href="https://en.wikipedia.org/wiki/Optical_Internetworking_Forum">OIF</a>) promotes the development of interoperable SerDes devices.</p>
<div id="ch07.sec5.sub1"></div>
<h3 id="751-physical-network-topologies">7.5.1 Physical Network Topologies</h3>
<p>There are different device-to-device and host-to-host physical network connection, as shown in Figure <a href="../ch07/#fig:phy-topo">7.15</a>. In the early days of high-performance computing (HPC) interconnects, low-radix topologies were the norm. Higher radix network topologies are becoming more common as the pin bandwidth increases and can be efficiently partitioned across multiple ports [<a href="../biblio/#kim2008">KDS+08</a>; <a href="../biblio/#kim2005">KDT+05</a>].</p>
<div id="fig:phy-topo"></div>
<p><img alt="" src="../figures/ch07-15.png" />
<em>Figure 7.15:</em> Examples of topology designs using 8 nodes. High-radix topologies provide lower communication latency across nodes. Based on [<a href="../biblio/#naumov2020">NKM+20</a>].</p>
<p>Distributing the training of large models across several nodes requires communicating a large number of weights or activations. Therefore, high node-to-node bandwidth is beneficial. The optional choice of the communication primitive algorithm is dependent on the physical network topology. High-radix topologies are preferable when the bandwidth can be effectively utilized, as is the case in the AllReduce-Ring algorithm, but not in the other AllReduce algorithms analyzed in Section <a href="../ch05/#ch05.sec4">5.4</a>.</p>
<div id="ch07.sec6"></div>
<h2 id="76-processors-in-production">7.6 Processors in Production</h2>
<p>There are several processors in production and development for DL, and <a href="https://github.com/fengbintu/Neural-Networks-on-Silicon">many more</a> in research. The number of processors is likely to expand in the next few years and later consolidate, similar to what happened with the DL frameworks, as detailed in Chapter <a href="../ch09/#ch09">9</a>. In this section, we discuss some of the most prominent processors in production and development.</p>
<p>CPUs are widely used for inference. Server CPUs are also used to train small models, models requiring large memory capacity, and large models <a href="https://ieeexplore.ieee.org/document/8327042">during off-peak hours</a> [<a href="../biblio/#hazelwood2018">Haz18</a>]. CPU designers continue to add more cores; the 2nd-generation Intel Xeon Scalable processors has <a href="https://ark.intel.com/content/www/us/en/ark/products/194146/intel-xeon-platinum-9282-processor-77m-cache-2-60-ghz.html">up to <span class="arithmatex">\(56\)</span> cores</a> and the AMD EPYC 2nd gen has <a href="https://www.amd.com/en/products/cpu/amd-epyc-7742">up to <span class="arithmatex">\(64\)</span> cores</a> [<a href="../biblio/#intel-xeon2019">Int19</a>; <a href="../biblio/#amd-epyc2019">Amd19</a>]. In addition, CPUs are incorporating specialized circuits and instructions to accelerate DL computations and reduce power overhead. Apple's A13 Arm-based CPU (used on the iPhone 11) has two cores with AMX blocks <a href="https://en.wikipedia.org/wiki/Apple_A13">dedicated</a> for matrix multiplications [<a href="../biblio/#wiki-apple-a13-2019">Wik19</a>]. Arm <a href="https://community.arm.com/developer/ip-products/processors/b/ml-ip-blog/posts/bfloat16-processing-for-neural-networks-on-armv8_2d00_a">introduced</a> additional instruction sets to accelerate <span class="arithmatex">\(bf16\)</span> multiplications on the Armv8-A architectures [<a href="../biblio/#stephens2019">Ste19b</a>]. Intel <a href="https://newsroom.intel.com/news/2020-ces-intel-news-livestream-replay/">introduced</a> extensions to the AVX512 ISA to support <span class="arithmatex">\(\mathit{int8}\)</span> and <span class="arithmatex">\(bf16\)</span>, and is adding the Intel Advanced Matrix Extensions (<a href="https://software.intel.com/content/dam/develop/public/us/en/documents/architecture-instruction-set-extensions-programming-reference.pdf">Intel AMX</a>) (not related to Apple's AMX) with 2D registers and dedicated <span class="arithmatex">\(\mathit{bfloat16}\)</span> and <span class="arithmatex">\(\mathit{int8}\)</span> acceleration starting with the Intel processor codenamed Sapphire Rapids [<a href="../biblio/#intel-xeon2019">Int19</a>; <a href="../biblio/#intel-xeon2020">Int20</a>; <a href="../biblio/#intel-isa2020">Int20b</a>]. IBM POWER10 cores have an embedded <a href="https://newsroom.ibm.com/2020-08-17-IBM-Reveals-Next-Generation-IBM-POWER10-Processor">Matrix Math Accelerator</a> to accelerate <span class="arithmatex">\(fp32\)</span>, <span class="arithmatex">\(bf16\)</span>, and <span class="arithmatex">\(\mathit{int8}\)</span> operations [<a href="../biblio/#ibm2020">Ibm20</a>].</p>
<p>GPUs have thousands of threads designed for embarrassingly parallel tasks, such as large batch GEMMs and convolutions. Some GPUs are also incorporating specialized features. Starting with the Volta microarchitecture, Nvidia added <a href="https://developer.nvidia.com/tensor-cores">tensor cores</a> to <a href="https://www.nvidia.com/en-us/data-center/v100/">increase</a> <span class="arithmatex">\(fp16\)</span> MACs throughput. The Turing microarchitecture <a href="https://www.nvidia.com/en-us/data-center/tesla-t4/">added</a> <span class="arithmatex">\(\mathit{int8}\)</span> and <span class="arithmatex">\(\mathit{int4}\)</span>, and the Ampere microarchitecture <a href="https://www.nvidia.com/en-us/data-center/a100/">added</a> <span class="arithmatex">\(\mathit{bfloat16}\)</span> and <span class="arithmatex">\(fp19\)</span> support to the tensor cores. Nvidia also designed an RISC-V-based dataflow architecture <a href="https://research.nvidia.com/sites/default/files/pubs/2019-08_A-0.11-pJ/Op%2C//HotChips_RC18_final.pdf">RC-18</a> for fast low power inference <a href="https://www.nextplatform.com/2019/09/03/nvidia-shows-off-tech-chops-with-rc18-inference-chip/">possibly available</a> in the (<a href="https://en.wikipedia.org/wiki/Hopper_(microarchitecture)">tentatively</a> called) Hopper microarchitecture [<a href="../biblio/#venkatesan2019">VSZ+19</a>; <a href="../biblio/#morgan2019">Mor19</a>].</p>
<p>AMD also produces GPUs but has not found the same success as Nvidia. The primary gap AMD GPUs have is the limited DL software ecosystem. AMD shifted from a single family of microarchitectures, the graphics core next (GCN), which expanded five generations, to two families: the RDNA and CDNA microarchitectures. The Vega GPUs use the GCN 5th generation. The Navi GPUs use the RDNA graphics microarchitecture. The Arcturus GPUs use the CDNA compute microarchitecture starting with the Radeon Instinct MI100. AMD <a href="https://github.com/ROCmSoftwarePlatform/MIOpen/releases">added</a> <span class="arithmatex">\(\mathit{bfloat16}\)</span> support to their ROCm MIOpen DL software library, a likely indicator of support in the CDNA architecture.</p>
<p>Intel <a href="https://newsroom.intel.com/news-releases/intel-unveils-new-gpu-architecture-optimized-for-hpc-ai-oneapi/">plans to release</a> a discrete general-purpose GPU for HPC modeling and DL training based on Intel's <span class="arithmatex">\(X^e\)</span> architecture, codenamed Ponte Vecchio. Among the <a href="https://newsroom.intel.com/wp-content/uploads/sites/11/2019/11/Aurora-Supercomputer.pdf">adopters</a> is the Aurora supercomputer at Argonne National Laboratory [<a href="../biblio/#intel-sc2019">Kod19</a>; <a href="../biblio/#intel-aurora2019">Int19b</a>].</p>
<p>FPGAs have some adoption in production for ML workloads. For instance, Microsoft <a href="https://www.microsoft.com/en-us/research/project/project-brainwave/">Brainwave</a> and <a href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-fpga-web-service">Azure</a> provides ML services on FPGAs. The primary FPGAs makers are Intel (after acquiring Altera) and Xilinx. Both offer high-level software libraries to facilitate using FPGAs with a predefined set of DL primitives: <a href="https://software.intel.com/en-us/openvino-toolkit/choose-download/free-download-linux-fpga">OpenVINO</a> and <a href="https://github.com/Xilinx/ml-suite">Xilinx ML Suite</a>.</p>
<p>Xilinx introduced the Adaptive Compute Acceleration Platform (<a href="https://www.xilinx.com/support/documentation/white_papers/wp505-versal-acap.pdf">ACAP</a>) combining an Arm-based CPU, a vector processor engine, and an FPGA in a high-bandwidth NoC [<a href="../biblio/#xilinx-acap2019">Xil19</a>]. Intel has <a href="https://ieeexplore.ieee.org/document/8735536">demonstrated</a> the benefits of enhancing FPGA with specialized tensor functions [<a href="../biblio/#nurvitadhi2019">NKJ+19</a>].</p>
<p>Established silicon vendors, startups, and hyperscalers are developing a spectrum of specialized DL processors, often using a mixture of ASICs and DSPs. Google was the first to succeed at scale with the Tensor Processing Unit (TPU). The TPU is used for a range of DL workloads by several companies, including Google, <a href="https://tech.ebayinc.com/engineering/large-scale-product-image-recognition-with-cloud-tpus/">eBay</a>, and the <a href="https://arxiv.org/abs/1909.03108">Mayo Clinic</a> [<a href="../biblio/#zheng2018">ZZZ+18</a>; <a href="../biblio/#hou2019">Hou19</a>]. TPU v1 is designed for <span class="arithmatex">\(\mathit{int8}\)</span> inference workloads, and v2-v4 are designed for training, although inference is also <a href="https://cacm.acm.org/magazines/2020/7/245702-a-domain-specific-supercomputer-for-training-deep-neural-networks/fulltext">supported</a> at lower latency and higher throughput than v1 [<a href="../biblio/#jouppi2020">JYK+20</a>]. TPU v2-v4 adds <span class="arithmatex">\(bf16\)</span> support, HBM, and improves the scalar, vector, and matrix (systolic array) units. TPU v2 (and possibly other generations) uses VLIW and software-managed instructions. Other specialized processors developed by hyperscalers for their cloud services are: <a href="https://aws.amazon.com/ec2/instance-types/inf1/">AWS Inferentia</a>, Alibaba <a href="https://www.alibabacloud.com/blog/announcing-hanguang-800-alibabas-first-ai-inference-chip_595482">Hanguang 800 NPU</a>, and Baidu <a href="https://cloud.baidu.com/">Kunlun</a> [<a href="../biblio/#aws-inf12019">Ama19</a>; <a href="../biblio/#aws-reinvent2019">Ama19b</a>; <a href="../biblio/#zhang2019">ZLH+19</a>; <a href="../biblio/#jiao2020">JHJ+20</a>; <a href="../biblio/#baidu-kunlun2020">Bai20</a>].</p>
<p>Specialized processors developed by established and merchant market silicon vendors include the Intel Habana processors, the Intel Movidius <a href="https://www.movidius.com/myriadx">Myriad-X</a> edge inference processor, the Qualcomm <a href="https://www.qualcomm.com/products/datacenter-artificial-intelligence">Cloud AI 100</a> inference processor, and the Huawei <a href="https://e.huawei.com/us/products/cloud-computing-dc/atlas/ascend-910">Ascend 910</a> training processor. The Habana <a href="https://habana.ai/wp-content/uploads/pdf/habana_labs_goya_whitepaper.pdf">Goya</a> inference processor and the Habana <a href="https://habana.ai/wp-content/uploads/2019/06/Habana-Gaudi-Training-Platform-whitepaper.pdf">Gaudi</a> training processor both use a scalable architecture of C-programmable VLIW SIMD vector processors called Tensor Processing Cores (TPC).</p>
<p>Prominent startups with unique designs are Cerebras System, Graphcore, SambaNova, and Groq. Cerebras Systems <a href="https://www.cerebras.net/product/">CS-1</a> is designed to facilitate distributed training. Rather than manufacturing multiple chips from a silicon wafer and then using SerDes to connect them, CS-1 uses one gigantic TSMC 16 nm chip, called a <em>wafer scaled engine</em> (WSE), which uses an entire silicon wafer. Thus, CS-1 consolidates multiple chips into a single chip with <span class="arithmatex">\(1.2T\)</span> transistors. The design has redundancy to account for defects in parts of the wafer, typical in the manufacturing process. The Gen-2 WSE, introduced in Aug. 2020, more than doubles the Gen-1 cores and transistors.</p>
<p>Graphcore released the TSMC 7 nm MK2 2nd-generation Intelligence Processing Unit (<a href="https://www.graphcore.ai/products/ipu">IPU</a>) in July 2020. The majority of the die is dedicated to the <span class="arithmatex">\(900\)</span> MB SRAM interlaced throughout the computing clusters totaling <span class="arithmatex">\(fp16\rightarrow fp16\)</span> <span class="arithmatex">\(250\)</span> TOPS. The intent is that the SRAM is large enough to hold the entire model on a chip facilitating high-efficiency small batch training and inference. Each PCIe card contains two IPUs with high chip-to-chip bandwidth so that a model can be split between them. Microsoft <a href="https://www.graphcore.ai/posts/microsoft-and-graphcore-collaborate-to-accelerate-artificial-intelligence">has deployed</a> the 1st-generation IPU processors in the Azure cloud [<a href="../biblio/#gc-azure2019">Gra19</a>]. It is unclear if the <span class="arithmatex">\(fp16\rightarrow fp16\)</span> MACs (rather than <span class="arithmatex">\(fp16\rightarrow fp32\)</span> MACs) may present a convergence challenge for some workloads, or if this increases the complexities to port existing code from a different architecture into MK2.</p>
<p>SambaNova is developing the Reconfigurable Dataflow Unit (RDU) <a href="https://sambanova.ai/pushing-computer-vision-boundaries-beyond-4k/">designed</a> as a dataflow architecture, possibly based on the <a href="https://dl.acm.org/doi/10.1145/3140659.3080256">Plasticine CGRA</a> architecture [<a href="../biblio/#prabhakar2017">PZK+17</a>]. SambaNova <a href="https://sambanova.ai/a-new-state-of-the-art-in-nlp-beyond-gpus/">developed</a> the DataScale System with petaflops of performance and terabytes of memory capable of efficiently training a <span class="arithmatex">\(100\)</span> billion parameter model.</p>
<p>Groq's <a href="https://ieeexplore.ieee.org/document/9138986">Tensor Streaming Processor</a> (TSP) supports <span class="arithmatex">\(fp16\)</span> and <span class="arithmatex">\(\mathit{int8}\)</span> multipliers. It <a href="https://groq.com/technology/">offers</a> <span class="arithmatex">\(820\)</span> <span class="arithmatex">\(\mathit{int8}\)</span> TOPS and <span class="arithmatex">\(220\)</span> MB SRAM. Similar to Graphcore's MK2 IPU, the large SRAM capacity is beneficial for small-batch processing. The TSP can be reconfigured at every cycle by software using ahead-of-time compilation [<a href="../biblio/#abts2020">ARS+20</a>]. It <a href="https://www.nimbix.net/groq">is deployed</a> at Nimbix cloud [<a href="../biblio/#nimbix2020">Nim20</a>].</p>
<p>CS-1, Graphcore's IPU, and Groq's TSP designed chips with large SRAM to reduce the cost and time to fetch data from main memory. Training, however, requires storing the activations, which can exceed the available SRAM. To fully realize their potential, pipeline parallelism with gradient checkpoints, introduced in Section <a href="../ch05/#ch05.sec2.sub1">5.2.1</a>, is likely required to avoid main memory accesses. While pipeline parallelism suffers from similar drawbacks as Async SDG, recent algorithmic <a href="https://arxiv.org/pdf/2003.11666.pdf">improvements</a> are showing promising results on small-scale experiments [<a href="../biblio/#kosson2020">KCV+20</a>]. Further advancements in pipeline parallelism are necessary to deliver on these chips' potential.</p>
<div id="ch07.sec7"></div>
<h2 id="77-platforms-strengths-and-challenges">7.7 Platforms Strengths and Challenges</h2>
<p>DL platforms must balance memory, bandwidth, general-purpose compute, and dedicated compute to effectively train and serve DL workloads with heterogeneous characteristics. State-of-the-art recommender models and emerging GNN models require more general-purpose compute than NLP or computer vision workloads. A platform should also be programmable and sufficiently flexible to adapt to novel workloads with different demands. Given the larger complexities of training, we focus on training platforms in this section and review the Nvidia DGX, Google TPU POD, Habana HLS-1, Graphcore M2000, Cerebras CS-1, AMD CDNA-based, Hyve Solutions Catalina, and Facebook Zion platform.</p>
<p>Nvidia markets GPU-accelerated servers (DGX) and racks (POD). NVLink with NVSwitch connects the GPUs within a server, and InfiniBand connects racks of servers for scale-out. The intra-server NVLink connectors facilitate model parallelism as the entire server can be treated as one large compute unit while the inter-server InfiniBand primarily facilitates data parallelism. The SuperPOD-based Selene supercomputer ranked <span class="arithmatex">\(7\)</span>th in the TOP500 June 2020 <a href="https://www.top500.org/lists/top500/2020/06/">list</a>. The platform's biggest strength and enormous competitive advantage is the mature software, and the robust ecosystem including multiple active online forums. Also, the extensive market adoption of Nvidia GPUs results in better economies of scale lowering production costs. The Ampere microarchitecture offers multi-instance GPU (MIG); a single A100 can be partitioned into up to seven virtual GPUs, each of which gets its dedicated allocation of cores, L2 cache, and memory controllers. This partition is particularly beneficial for small-batch inference, as using the entire GPU would result in low compute utilization.</p>
<p>Google designed the TPU POD connecting many TPUs with custom interconnects (the chips have integrated routers) to work on a single workload offering over <span class="arithmatex">\(100\)</span> PFLOPS on the TPUv3 POD. The TPUv2 POD uses a flat 2D torus physical network topology across all <span class="arithmatex">\(16\times16\)</span> TPUs. The TPUv3 POD has <span class="arithmatex">\(1024\)</span> TPUs, and possibly uses a <span class="arithmatex">\(32\times32\)</span> 2D torus network topology. Google <a href="https://cloud.google.com/blog/products/ai-machine-learning/google-breaks-ai-performance-records-in-mlperf-with-worlds-fastest-training-supercomputer">demonstrated</a> the fastest training time in six of the eight MLPerf workloads (the DGX A100-based POD won the remainder two) in the July 2020 submission using a TPUv4 POD. The MLPerf benchmark is discussed in Section <a href="../ch07/#ch07.sec8">7.8</a>. The flat network topology does not differentiate between local and global bandwidth since the fabric is organized as a single, global topology. The biggest competitive advantage is the first-to-market data center DL accelerator as an alternative to Nvidia GPUs. Also, having a dedicated DL processor with software-managed memory enables Google to design the TPU with <a href="https://cacm.acm.org/magazines/2020/7/245702-a-domain-specific-supercomputer-for-training-deep-neural-networks/fulltext">comparable performance</a> to a contemporary Nvidia GPU but using an older semiconductor process, which lowers costs. Facebook and Google are <a href="https://github.com/pytorch/xla">collaborating</a> to add TPU support to PyTorch. PyTorch and TensorFlow are the dominant DL libraries in industry and are detailed in Sections <a href="../ch09/#ch09.sec2">9.2</a> and <a href="../ch09/#ch09.sec3">9.3</a>. The primary inference challenge with the TPU design is the large matrix multiply units (<span class="arithmatex">\(256\times 256\)</span> or <span class="arithmatex">\(128\times 128\)</span>), which are beneficial for large-batches but typically result in low-utilization for small-batch processing. While Google can aggregate hundreds of inference requests in real-time into a batch, non-Google TPU users with much smaller scales may not be able to carry out large-batch inference.</p>
<p>Habana, an Intel company, developed the Habana Labs System-1 (<a href="https://habana.ai/wp-content/uploads/2019/06/Habana-Gaudi-Training-Platform-whitepaper.pdf">HLS-1</a>) with eight Habana Gaudi cards. Gaudi integrates RDMA engines on the chip and uses industry-standard Ethernet as the physical interface without requiring a NIC to communicate within and across platforms. Each Gaudi in HLS-1 <a href="https://habana.ai/wp-content/uploads/2019/06/HLS-1-Datasheet.pdf">uses</a> ten <span class="arithmatex">\(100\)</span> Gbps RoCE channels: seven for intra-box connectivity and three for scale-out [<a href="../biblio/#hls2019">Hab19b</a>]. A strength of HLS-1 is using Ethernet, which facilitates using the existing Ethernet infrastructure. Also, the HLS-1 platform does not include a CPU; it provides PCIe switches for a host interface, and the user determines the right CPU to Gaudi ratio. Thus, the HLS-1 platform decouples the management traffic to PCIe and the scale-out traffic to Ethernet, which mitigates PCIe and scale-out bottlenecks. Lastly, the Habana training and inference processors share a similar design and programming model, which reduces the training to inference switching costs.</p>
<p>Graphcore <a href="https://www.graphcore.ai/mk2-ipu-m2000-white-paper">developed</a> the IPU-Machine M2000 platform. Each platform has <span class="arithmatex">\(4\)</span> MK2 IPU devices disaggregated from the CPU (similar to HLS-1 in this regard). Graphcore developed the reference architecture IPU-POD64 with <span class="arithmatex">\(16\)</span> M2000 platforms totaling <span class="arithmatex">\(64\)</span> MK2 IPUs. Graphcore offers a hybrid model with proprietary IPU-Links connecting the IPUs within an IPU-POD64 in a 2D torus physical topology and provides IPU access over RoCE to scale outside an IPU-POD [<a href="../biblio/#ipu2020">Gra20</a>]. A strength is the large IPU SRAM capacity for high-efficiency, small-batch processing. Also, Graphcore is <a href="https://www.graphcore.ai/posts/microsoft-and-graphcore-collaborate-to-accelerate-artificial-intelligence">collaborating</a> with Microsoft, a large company with a diverse set of workloads and large datasets, which can help Graphcore mature their software on relevant workloads. One challenge is the lack of <span class="arithmatex">\(fp32\)</span> accumulation in the MK2 IPU <span class="arithmatex">\(fp16\)</span> MACs, which may impact training accuracy in some workloads.</p>
<p>Cerebras System markets a clusters of CS-1s. This platform is <a href="https://www.cerebras.net/cerebras-deploys-the-cs-1-the-industrys-fastest-ai-computer-at-argonne-national-lab/">deployed</a> at Argonne National Laboratory (ANL) [<a href="../biblio/#feldman2019-b">Fel19b</a>], and <a href="https://www.cerebras.net/pittsburgh-supercomputing-center-selects-cerebras-to-power-its-new-groundbreaking-ai-supercomputer-neocortex/">two systems</a> at the AI supercomputer Neocortex in the Pittsburgh Supercomputing Center (PSC). The strength of CS-1 is consolidating multiple DL chips into a gigantic processor, which provides high-bandwidth for distributed training and large SRAM capacity. Similar to the MK2 IPU, the large SRAM facilitates small-batch processing. The primary challenges are the inability to modify the dedicated compute, bandwidth, and CPU ratios, and effectively utilizing all the available compute.</p>
<p>AMD GPU-accelerated <a href="https://www.amd.com/en/graphics/servers-radeon-instinct-deep-learning">servers</a> use the AMD Infinity Fabric Link to directly connect up to <span class="arithmatex">\(2\)</span> GPU hives of <span class="arithmatex">\(4\)</span> GPUs per hive. AMD CDNA-based GPUs are accelerating the <a href="https://www.amd.com/en/press-releases/2020-03-04-next-generation-amd-epyc-cpus-and-radeon-instinct-gpus-enable-el-capitan">El Capitan</a> supercomputer in 2023, and <a href="https://www.amd.com/en/press-releases/2020-03-05-amd-details-strategy-to-deliver-best-class-growth-and-strong-shareholder">use</a> the high-bandwidth, low latency 3rd-generation AMD Infinity Architecture links between <span class="arithmatex">\(4\)</span> GPUs and <span class="arithmatex">\(1\)</span> CPU. AMD is growing its ecosystem with hyperscalers, which may facilitate entry into the DL market, and having a system with a CPU and a GPU developed by the same company may simplify running workloads on the heterogeneous system.</p>
<p>Hyve Solutions designed the <a href="https://hyvesolutions.com/catalina-with-new-3rd-gen-intel-xeon-scalable-processors-for-deep-learning-and-hpc-applications/">Catalina</a> platform using eight sockets of 3rd-generation Intel Xeon Scalable processors, which double and quadruple the <span class="arithmatex">\(bf16\)</span> and <span class="arithmatex">\(\mathit{int8}\)</span> theoretical peak compute, respectively, over AVX512 <span class="arithmatex">\(fp32\)</span>. The strength is fungible computing. It can be used for DL training and inference, traditional ML, HPC, and general-purpose workloads. The challenge is the lower performance compared to a dedicated DL training platform for users who can maintain the dedicated platform utilized the majority of the time.</p>
<p>Facebook <a href="https://arxiv.org/abs/2003.09518">designed</a> the large-memory unified training platform <a href="https://engineering.fb.com/data-center-engineering/accelerating-infrastructure/">Zion</a> that consists of both CPUs and accelerators and provides disaggregated memory, compute, and network components, allowing each to scale independently [<a href="../biblio/#naumov2020">NKM+20</a>]. The CPU chassis Angels Landing is composed of four dual-socket CPU modules. The accelerator chassis Emeralds Pools uses up to eight vendor-agnostic OCP accelerator modules (OAMs) with high-speed high-bandwidth interconnects. The OAM form factor, co-developed by Facebook, Baidu, and Microsoft, allows hardware vendors to develop accelerators with a standard specification. The platform has three types of interconnect fabrics--the CPU fabric, the accelerator fabric, and the PCIe interconnect that provides connectivity between CPUs and accelerators. The strength of Zion is its capacity to support a broad spectrum of DL workloads. Those with significant memory demands can use the large DRAM capacity in the eight-socket platform, and those with significant compute and memory bandwidth demands can benefit from the HBM and specialized compute in the accelerators. The challenge is the software complexity to move the data and use all the available compute efficiently. All platforms discussed in this section share this challenge, and it becomes more prevalent the more heterogeneous is the platform.</p>
<div id="ch07.sec8"></div>
<h2 id="78-evaluating-devices-and-platforms">7.8 Evaluating Devices and Platforms</h2>
<p>An important metric is the total cost of operating the hardware, including the hardware's cost, the maintenance over its lifetime, and the software engineers to program the hardware. The ease-of-programming to support a wide spectrum of topologies at high performance is an important part of the evaluation, which cannot be overstated.</p>
<p>Unsurprisingly, different products have different use cases. Training hardware is optimized for throughput. Inference hardware is optimized for latency, and edge hardware is optimized for power and size. Also, a topology may have an affinity to a specific processor. While the number of weights, number of layers, and size of activations can affect performance, it is essential to evaluate a topology in the context of a particular hardware architecture. Critical metrics for a topology and hardware pair are statistical performance, computational performance, and power consumption.</p>
<p>The following platforms facilitate evaluating DL hardware. <a href="https://fires.im/">FireSim</a> is an FPGA-based hardware simulator available on AWS FPGA instances; the Nvidia DL Accelerator (NVDLA) <a href="https://arxiv.org/abs/1903.06495">is integrated</a> on FireSim [<a href="../biblio/#karandikar2018">KBA18</a>; <a href="../biblio/#farshchi2019">FHY19</a>]. The <a href="https://arxiv.org/abs/1912.04481">SMAUG</a> and <a href="https://arxiv.org/abs/1807.07928">Eyexam</a> packages model the performance of a topology on an accelerator design [<a href="../biblio/#xi2019">XYB+19</a>; <a href="../biblio/#chen2019-d">CYE+19</a>]. The <a href="https://arxiv.org/abs/1907.10701">ParaDnn</a> tool is used to benchmark DL platforms against TPUs, GPUs, and CPUs [<a href="../biblio/#wang2019-e">WWB19</a>]. <a href="https://arxiv.org/abs/1909.06842">Wang et al.</a> and <a href="https://arxiv.org/abs/1907.03626">Dai et al.</a> provide performance comparisons on various hardware targets [<a href="../biblio/#wang2019-f">WWS+19</a>; <a href="../biblio/#dai2019">DB19</a>].</p>
<p>The community is developing a suite of benchmarks, such as <a href="https://github.com/baidu-research/DeepBench">DeepBench</a> to evaluate primitives, <a href="https://dawn.cs.stanford.edu/benchmark/">DAWNBench</a> to evaluate performance and cost on a public cloud service, and <a href="https://mlperf.org/">MLPerf</a> [<a href="../biblio/#deepbench2019">Dee19</a>; <a href="../biblio/#dawnbench2020">Daw20</a>; <a href="../biblio/#mlperf2018">Mlp18</a>]. MLPerf is the most popular benchmark backed by a consortium made up of some of the biggest <a href="https://mlperf.org/about/#contributors">companies</a> in DL and evaluates performance across well-established models.</p>
<p>While benchmarks are essential to evaluate DL systems, a potential danger is overfitting the hardware and software <a href="https://dl.acm.org/doi/10.1145/3317550.3321441">designs</a> to a benchmark. Most benchmarks focus on the past rather than the future. It may be wise to develop benchmark metrics that provide a measure of the platform's programmability and flexibility to support a diverse range of workloads. This metric should include the compilation time required to obtain high efficiency on these models.</p>
<p>In this chapter, we reviewed the basics component of DL hardware and the ample design space for training and inference. We detailed why a smaller numerical representation requires less silicon and power and discussed some of the performance vs. ease-of-programmability tradeoffs across various hardware designs used for DL: CPUs, GPUs, DSPs, FPGAs, CGRAs, and ASICs, as well as heterogeneous designs. We recommended a high-level ASIC design to maximize OPS per watt with sufficient die area for SRAM and other critical circuitry. We discussed the high cost of accessing DRAM memory and the pipeline parallelism related challenge that large SRAM training processors have to overcome to deliver on their potential. We highlighted prominent DL processors and platforms in production and development and emphasized the need for a flexible and programmable platform that supports a broad spectrum of workloads to gain wide adoption. Given the approximately two to three years to bring hardware from concept into production, a platform needs to account for unforeseen algorithmic and model innovations. A flexible platform design may include disaggregated CPU to accelerator ratio, a standard form factor module, and an industry-standard interconnect to scale out the architecture. This flexibility facilitates the evaluation and adoption of heterogeneous processors, which is important to data center managers to avoid being locked into one vendor. Moreover, while flexibility comes at the expense of some performance, given the rapid algorithmic innovation, the benefit is likely worth this price. We also discussed the challenges with software-managed memory and the complexities to extract high performance; the program needs to efficiently map to the target hardware via compilers accurately matching memory accesses to the ALU or FPU logic inputs and results. In the next chapter, we review the basics of compilers and describe the standard compiler optimizations passes for DL workloads.</p>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../ch08/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../ch08/" class="btn btn-xs btn-link">
        Chapter 8: Compiler Optimizations
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../ch06/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../ch06/" class="btn btn-xs btn-link">
        Chapter 6: Reducing the Model Size
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>